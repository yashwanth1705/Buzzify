"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/store.ts":
/*!**********************!*\
  !*** ./lib/store.ts ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n\n// Demo users\nconst demoUsers = [\n    {\n        id: 1,\n        name: 'Admin User',\n        email: 'admin@college.edu',\n        password: 'admin123',\n        role: 'admin',\n        status: 'active',\n        department: 'Administration',\n        phone_number: '1234567890',\n        dob: '1985-01-15',\n        age: 39,\n        blood_group: 'O+'\n    },\n    {\n        id: 2,\n        name: 'Staff Member',\n        email: 'staff@college.edu',\n        password: 'staff123',\n        role: 'staff',\n        status: 'active',\n        department: 'Computer Science',\n        phone_number: '0987654321',\n        dob: '1990-05-20',\n        age: 34,\n        blood_group: 'A+'\n    },\n    {\n        id: 3,\n        name: 'John Student',\n        email: 'student@college.edu',\n        password: 'student123',\n        role: 'student',\n        status: 'active',\n        department: 'Computer Science',\n        course: 'B.Tech',\n        sub_course: 'Computer Science',\n        phone_number: '1122334455',\n        parent_phone: '9988776655',\n        responsible_staff: 'Staff Member',\n        dob: '2003-08-10',\n        age: 21,\n        blood_group: 'B+'\n    },\n    {\n        id: 4,\n        name: 'Sarah Johnson',\n        email: 'sarah@college.edu',\n        password: 'student123',\n        role: 'student',\n        status: 'active',\n        department: 'Computer Science',\n        course: 'B.Tech',\n        sub_course: 'Computer Science',\n        phone_number: '2233445566',\n        parent_phone: '8877665544',\n        responsible_staff: 'Staff Member',\n        dob: '2003-03-15',\n        age: 21,\n        blood_group: 'A-'\n    },\n    {\n        id: 5,\n        name: 'Michael Brown',\n        email: 'michael@college.edu',\n        password: 'student123',\n        role: 'student',\n        status: 'active',\n        department: 'Electronics',\n        course: 'B.Tech',\n        sub_course: 'Electronics',\n        phone_number: '3344556677',\n        parent_phone: '7766554433',\n        responsible_staff: 'Staff Member',\n        dob: '2002-11-22',\n        age: 22,\n        blood_group: 'O-'\n    }\n];\n// Demo groups\nconst demoGroups = [\n    {\n        id: 1,\n        name: 'Computer Science Students',\n        description: 'All students from Computer Science department',\n        created_by: 'admin@college.edu',\n        members: [\n            'student@college.edu',\n            'sarah@college.edu'\n        ],\n        created_at: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()\n    },\n    {\n        id: 2,\n        name: 'B.Tech 2024 Batch',\n        description: 'Students from 2024 batch',\n        created_by: 'admin@college.edu',\n        members: [\n            'student@college.edu',\n            'sarah@college.edu',\n            'michael@college.edu'\n        ],\n        created_at: new Date(Date.now() - 25 * 24 * 60 * 60 * 1000).toISOString()\n    }\n];\n// Demo departments\nconst demoDepartments = [\n    {\n        id: 1,\n        name: 'Computer Science',\n        description: 'Department of Computer Science and Engineering',\n        head_of_department: 'Dr. Smith',\n        created_by: 'admin@college.edu',\n        created_at: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString()\n    },\n    {\n        id: 2,\n        name: 'Electronics',\n        description: 'Department of Electronics and Communication',\n        head_of_department: 'Dr. Johnson',\n        created_by: 'admin@college.edu',\n        created_at: new Date(Date.now() - 300 * 24 * 60 * 60 * 1000).toISOString()\n    },\n    {\n        id: 3,\n        name: 'Mechanical Engineering',\n        description: 'Department of Mechanical Engineering',\n        head_of_department: 'Dr. Brown',\n        created_by: 'admin@college.edu',\n        created_at: new Date(Date.now() - 250 * 24 * 60 * 60 * 1000).toISOString()\n    },\n    {\n        id: 4,\n        name: 'Civil Engineering',\n        description: 'Department of Civil Engineering',\n        head_of_department: 'Dr. Davis',\n        created_by: 'admin@college.edu',\n        created_at: new Date(Date.now() - 200 * 24 * 60 * 60 * 1000).toISOString()\n    },\n    {\n        id: 5,\n        name: 'Administration',\n        description: 'Administrative Department',\n        head_of_department: 'Principal',\n        created_by: 'admin@college.edu',\n        created_at: new Date(Date.now() - 400 * 24 * 60 * 60 * 1000).toISOString()\n    }\n];\nconst useStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)((set, get)=>({\n        // Initial State\n        currentUser: null,\n        isAuthenticated: false,\n        isDarkMode: false,\n        users: demoUsers,\n        messages: [],\n        groups: demoGroups,\n        departments: demoDepartments,\n        courses: [],\n        subCourses: [],\n        notifications: [],\n        comments: [],\n        // Authentication Actions\n        login: async (email, password, role)=>{\n            // First try to find in local users (including newly added ones)\n            let user = get().users.find((u)=>u.email === email && u.password === password && u.status === 'active');\n            // If not found locally, try to fetch from Supabase\n            if (!user) {\n                try {\n                    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('users').select('*').eq('email', email).eq('password', password).eq('status', 'active').single();\n                    if (data && !error) {\n                        user = data;\n                        // Add to local state\n                        set((state)=>({\n                                users: [\n                                    ...state.users,\n                                    user\n                                ]\n                            }));\n                    }\n                } catch (supabaseError) {\n                    console.warn('Supabase login failed, using local storage only');\n                }\n            }\n            // Validate role if provided\n            if (user && role && user.role !== role) {\n                console.warn(\"Role mismatch: User has role '\".concat(user.role, \"' but login attempted with role '\").concat(role, \"'\"));\n                return Promise.resolve(false);\n            }\n            if (user) {\n                // Normalize user shape to avoid runtime crashes when UI expects fields\n                const normalizedUser = {\n                    // preserve original properties first\n                    ...user,\n                    // then ensure required fields exist and have safe defaults\n                    id: typeof user.id === 'number' ? user.id : Number(user.id) || 0,\n                    name: user.name || user.full_name || user.email || 'Unknown User',\n                    email: user.email || '',\n                    role: user.role || 'student',\n                    status: user.status || 'active',\n                    department: user.department || 'N/A',\n                    phone_number: user.phone_number || ''\n                };\n                if (!normalizedUser.id) {\n                    console.warn('Login: user has no numeric id, assigned fallback id 0. This may indicate inconsistent user schema.');\n                }\n                set({\n                    currentUser: normalizedUser,\n                    isAuthenticated: true\n                });\n                return Promise.resolve(true);\n            }\n            return Promise.resolve(false);\n        },\n        logout: ()=>{\n            set({\n                currentUser: null,\n                isAuthenticated: false\n            });\n        },\n        toggleTheme: ()=>{\n            const newTheme = !get().isDarkMode;\n            set({\n                isDarkMode: newTheme\n            });\n            localStorage.setItem('theme', newTheme ? 'dark' : 'light');\n            if (newTheme) {\n                document.documentElement.classList.add('dark');\n            } else {\n                document.documentElement.classList.remove('dark');\n            }\n        },\n        // User Actions\n        addUser: async (userData)=>{\n            try {\n                // Save to local state first\n                const newUser = {\n                    ...userData,\n                    id: Math.max(...get().users.map((u)=>u.id), 0) + 1,\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                };\n                set((state)=>({\n                        users: [\n                            ...state.users,\n                            newUser\n                        ]\n                    }));\n                // Try to save to Supabase\n                try {\n                    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('users').insert([\n                        {\n                            name: userData.name,\n                            email: userData.email,\n                            password: userData.password,\n                            role: userData.role,\n                            status: userData.status,\n                            phone_number: userData.phone_number,\n                            department: userData.department,\n                            course: userData.course,\n                            sub_course: userData.sub_course,\n                            dob: userData.dob,\n                            age: userData.age,\n                            blood_group: userData.blood_group,\n                            parent_phone: userData.parent_phone,\n                            responsible_staff: userData.responsible_staff\n                        }\n                    ]).select().single();\n                    if (error) {\n                        console.warn('Supabase not configured or error occurred, using local storage:', error.message);\n                    } else {\n                        console.log('User saved to Supabase successfully');\n                    }\n                } catch (supabaseError) {\n                    console.warn('Supabase not available, using local storage only');\n                }\n            } catch (error) {\n                console.error('Failed to add user:', error);\n                throw error;\n            }\n        },\n        updateUser: async (id, userData)=>{\n            try {\n                // Update local state\n                set((state)=>({\n                        users: state.users.map((user)=>user.id === id ? {\n                                ...user,\n                                ...userData,\n                                updated_at: new Date().toISOString()\n                            } : user)\n                    }));\n                // Try to update in Supabase\n                try {\n                    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('users').update({\n                        name: userData.name,\n                        email: userData.email,\n                        password: userData.password,\n                        role: userData.role,\n                        status: userData.status,\n                        phone_number: userData.phone_number,\n                        department: userData.department,\n                        course: userData.course,\n                        sub_course: userData.sub_course,\n                        dob: userData.dob,\n                        age: userData.age,\n                        blood_group: userData.blood_group,\n                        parent_phone: userData.parent_phone,\n                        responsible_staff: userData.responsible_staff,\n                        updated_at: new Date().toISOString()\n                    }).eq('id', id).select();\n                    if (error) {\n                        console.warn('Supabase not configured or error occurred, using local storage:', error.message);\n                    } else {\n                        console.log('User updated in Supabase successfully');\n                    }\n                } catch (supabaseError) {\n                    console.warn('Supabase not available, using local storage only');\n                }\n            } catch (error) {\n                console.error('Failed to update user:', error);\n                throw error;\n            }\n        },\n        deleteUser: async (id)=>{\n            try {\n                // Delete from local state\n                set((state)=>({\n                        users: state.users.filter((user)=>user.id !== id)\n                    }));\n                // Try to delete from Supabase\n                try {\n                    const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('users').delete().eq('id', id);\n                    if (error) {\n                        console.warn('Supabase not configured or error occurred, using local storage:', error.message);\n                    } else {\n                        console.log('User deleted from Supabase successfully');\n                    }\n                } catch (supabaseError) {\n                    console.warn('Supabase not available, using local storage only');\n                }\n            } catch (error) {\n                console.error('Failed to delete user:', error);\n                throw error;\n            }\n        },\n        fetchUsers: async ()=>{\n            try {\n                const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('users').select('*').order('created_at', {\n                    ascending: false\n                });\n                if (error) throw error;\n                if (data) {\n                    set(()=>({\n                            users: data\n                        }));\n                }\n            } catch (error) {\n                console.error('Error fetching users:', error);\n            }\n        },\n        // Message Actions\n        addMessage: async (messageData)=>{\n            try {\n                // Try to save to Supabase first\n                let supabaseMessage = null;\n                try {\n                    // Attempt 1: Try to insert with read_by (new schema)\n                    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('messages').insert([\n                        {\n                            title: messageData.title,\n                            content: messageData.content,\n                            sender: messageData.sender,\n                            sender_role: messageData.sender_role,\n                            recipients: messageData.recipients,\n                            custom_groups: messageData.custom_groups,\n                            priority: messageData.priority,\n                            attachments: messageData.attachments,\n                            schedule_type: messageData.schedule_type,\n                            schedule_date: messageData.schedule_date,\n                            schedule_time: messageData.schedule_time,\n                            total_recipients: messageData.total_recipients,\n                            read_count: 0,\n                            read_by: [],\n                            acknowledged: false,\n                            acknowledged_by: []\n                        }\n                    ]).select().single();\n                    if (error) {\n                        // If error is about missing column, try fallback\n                        console.warn('Supabase insert with read_by failed, retrying without it:', error.message);\n                        const { data: retryData, error: retryError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('messages').insert([\n                            {\n                                title: messageData.title,\n                                content: messageData.content,\n                                sender: messageData.sender,\n                                sender_role: messageData.sender_role,\n                                recipients: messageData.recipients,\n                                custom_groups: messageData.custom_groups,\n                                priority: messageData.priority,\n                                attachments: messageData.attachments,\n                                schedule_type: messageData.schedule_type,\n                                schedule_date: messageData.schedule_date,\n                                schedule_time: messageData.schedule_time,\n                                total_recipients: messageData.total_recipients,\n                                read_count: 0,\n                                acknowledged: false,\n                                acknowledged_by: []\n                            }\n                        ]).select().single();\n                        if (retryError) {\n                            throw retryError;\n                        } else {\n                            supabaseMessage = retryData;\n                            console.log('Message saved to Supabase successfully (legacy schema):', retryData);\n                        }\n                    } else {\n                        supabaseMessage = data;\n                        console.log('Message saved to Supabase successfully:', data);\n                    }\n                } catch (supabaseError) {\n                    console.warn('Supabase operation failed, falling back to local storage', supabaseError);\n                }\n                // Create message object (use Supabase data if available, otherwise create local)\n                const newMessage = supabaseMessage || {\n                    id: Math.max(...get().messages.map((m)=>m.id), 0) + 1,\n                    title: messageData.title,\n                    content: messageData.content,\n                    sender: messageData.sender,\n                    sender_role: messageData.sender_role,\n                    recipients: messageData.recipients,\n                    custom_groups: messageData.custom_groups,\n                    priority: messageData.priority,\n                    attachments: messageData.attachments,\n                    schedule_type: messageData.schedule_type,\n                    schedule_date: messageData.schedule_date,\n                    schedule_time: messageData.schedule_time,\n                    total_recipients: messageData.total_recipients,\n                    read_count: 0,\n                    read_by: [],\n                    acknowledged: false,\n                    acknowledged_by: [],\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                };\n                // Save to local state\n                set((state)=>({\n                        messages: [\n                            newMessage,\n                            ...state.messages\n                        ]\n                    }));\n                // Create notifications for recipients\n                const { users, currentUser } = get();\n                let recipientUsers = [];\n                if (messageData.recipients === 'all') {\n                    recipientUsers = users.filter((u)=>u.id !== (currentUser === null || currentUser === void 0 ? void 0 : currentUser.id));\n                } else if (messageData.recipients === 'students') {\n                    recipientUsers = users.filter((u)=>u.role === 'student');\n                } else if (messageData.recipients === 'staff') {\n                    recipientUsers = users.filter((u)=>u.role === 'staff');\n                } else if (messageData.recipients === 'admins') {\n                    recipientUsers = users.filter((u)=>u.role === 'admin');\n                } else if (messageData.recipients === 'group' && messageData.custom_groups) {\n                    const targetEmails = new Set();\n                    const allGroups = get().groups;\n                    messageData.custom_groups.forEach((groupId)=>{\n                        const group = allGroups.find((g)=>g.id === groupId);\n                        if (group && group.members) {\n                            group.members.forEach((email)=>targetEmails.add(email));\n                        }\n                    });\n                    recipientUsers = users.filter((u)=>targetEmails.has(u.email));\n                }\n                // Create one notification per recipient (await to avoid races)\n                for (const user of recipientUsers){\n                    await get().addNotification({\n                        message_id: newMessage.id,\n                        user_id: user.id,\n                        message: \"New message: \".concat(messageData.title),\n                        read: false\n                    });\n                }\n            } catch (error) {\n                console.error('Failed to save message:', error);\n                throw error;\n            }\n        },\n        acknowledgeMessage: async (messageId, userId)=>{\n            try {\n                const state = get();\n                const currentUser = state.currentUser;\n                if (!currentUser) return;\n                const message = state.messages.find((m)=>m.id === messageId);\n                if (!message) return;\n                const currentAcknowledgedBy = message.acknowledged_by || [];\n                if (currentAcknowledgedBy.includes(userId)) return;\n                const newAcknowledgedBy = [\n                    ...currentAcknowledgedBy,\n                    userId\n                ];\n                // Update local state\n                set((state)=>({\n                        messages: state.messages.map((msg)=>msg.id === messageId ? {\n                                ...msg,\n                                acknowledged_by: newAcknowledgedBy,\n                                acknowledged: true\n                            } : msg)\n                    }));\n                // Try to save to Supabase\n                if (_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase) {\n                    try {\n                        // Update message acknowledged status\n                        const { data: updateData, error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('messages').update({\n                            acknowledged_by: newAcknowledgedBy\n                        }).eq('id', messageId).select();\n                        console.log('Supabase update result:', {\n                            updateData,\n                            updateError\n                        });\n                        if (updateError) {\n                            console.error('Error updating message acknowledgement:', updateError);\n                            // Try camelCase just in case\n                            const { error: retryError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('messages').update({\n                                acknowledgedBy: newAcknowledgedBy\n                            }).eq('id', messageId).select();\n                            if (!retryError) console.log('Retry with camelCase succeeded');\n                        }\n                        // Store acknowledgement details (ignore error if table doesn't exist)\n                        try {\n                            const { data: ackData, error: ackInsertError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('acknowledgements').insert({\n                                message_id: messageId,\n                                user_id: userId,\n                                user_name: currentUser.name,\n                                user_email: currentUser.email,\n                                user_role: currentUser.role,\n                                acknowledged_at: new Date().toISOString()\n                            }).select();\n                            if (ackInsertError) {\n                                // Common causes: table doesn't exist, RLS or permission issues (401), or schema mismatch\n                                console.warn('Failed to insert into acknowledgements table:', ackInsertError);\n                                if ((ackInsertError === null || ackInsertError === void 0 ? void 0 : ackInsertError.code) === '401' || String((ackInsertError === null || ackInsertError === void 0 ? void 0 : ackInsertError.message) || '').toLowerCase().includes('permission')) {\n                                    console.warn('[acknowledgements] Permission error (401). Check Supabase RLS policies and anon key permissions for inserting into `acknowledgements`.');\n                                }\n                            } else {\n                                console.log('[acknowledgements] Inserted acknowledgement row:', ackData);\n                            }\n                        } catch (ackError) {\n                            console.warn('Unexpected error inserting into acknowledgements table (may not exist or insufficient permissions):', ackError);\n                        }\n                    } catch (supabaseError) {\n                        console.error('Supabase operation failed:', supabaseError);\n                    }\n                }\n            } catch (error) {\n                console.error('Failed to acknowledge message:', error);\n            }\n        },\n        getMessageAcknowledgementDetails: (messageId)=>{\n            const state = get();\n            const message = state.messages.find((m)=>m.id === messageId);\n            if (!message) return {\n                acknowledged: [],\n                pending: []\n            };\n            const acknowledgedUserIds = message.acknowledged_by || [];\n            const acknowledged = state.users.filter((u)=>acknowledgedUserIds.includes(u.id));\n            // Get pending users based on message recipients\n            let allRecipients = [];\n            if (message.recipients === 'all') {\n                allRecipients = state.users.filter((u)=>{\n                    var _state_currentUser;\n                    return u.id !== ((_state_currentUser = state.currentUser) === null || _state_currentUser === void 0 ? void 0 : _state_currentUser.id);\n                });\n            } else if (message.recipients === 'students') {\n                allRecipients = state.users.filter((u)=>u.role === 'student');\n            } else if (message.recipients === 'staff') {\n                allRecipients = state.users.filter((u)=>u.role === 'staff');\n            }\n            const pending = allRecipients.filter((u)=>!acknowledgedUserIds.includes(u.id));\n            return {\n                acknowledged,\n                pending\n            };\n        },\n        markMessageAsRead: async (messageId)=>{\n            const state = get();\n            const currentUser = state.currentUser;\n            if (!currentUser) return;\n            const message = state.messages.find((m)=>m.id === messageId);\n            if (!message) return;\n            // Check if already read by this user\n            const currentReadBy = message.read_by || [];\n            if (currentReadBy.includes(currentUser.id)) return;\n            const newReadBy = [\n                ...currentReadBy,\n                currentUser.id\n            ];\n            const newReadCount = (message.read_count || 0) + 1;\n            // Update local state\n            set((state)=>({\n                    messages: state.messages.map((msg)=>msg.id === messageId ? {\n                            ...msg,\n                            read_count: newReadCount,\n                            read_by: newReadBy\n                        } : msg)\n                }));\n            // Update Supabase\n            if (_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase) {\n                try {\n                    const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('messages').update({\n                        read_count: newReadCount,\n                        read_by: newReadBy\n                    }).eq('id', messageId);\n                    if (error) {\n                        console.warn('Failed to update read_by, falling back to simple read_count increment', error);\n                        // Fallback: just update read_count\n                        await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('messages').update({\n                            read_count: newReadCount\n                        }).eq('id', messageId);\n                    }\n                } catch (error) {\n                    console.error('Error updating message read status:', error);\n                }\n            }\n        },\n        fetchMessages: async ()=>{\n            try {\n                // Try normal fetch first\n                const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('messages').select('*').order('created_at', {\n                    ascending: false\n                });\n                if (error) {\n                    // If PostgREST returns an error due to missing columns in schema (400),\n                    // retry with a safe reduced column list that should exist on most schemas.\n                    console.warn('[fetchMessages] Initial fetch failed, retrying with safe column set:', error);\n                    try {\n                        const safeColumns = [\n                            'id',\n                            'title',\n                            'content',\n                            'sender',\n                            'sender_role',\n                            'recipients',\n                            'custom_groups',\n                            'priority',\n                            'attachments',\n                            'schedule_type',\n                            'schedule_date',\n                            'schedule_time',\n                            'total_recipients',\n                            'read_count',\n                            'acknowledged',\n                            'created_at',\n                            'updated_at'\n                        ].join(',');\n                        const { data: safeData, error: safeError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('messages').select(safeColumns).order('created_at', {\n                            ascending: false\n                        });\n                        if (safeError) {\n                            console.error('[fetchMessages] Safe retry also failed:', safeError);\n                            return;\n                        }\n                        if (safeData && Array.isArray(safeData) && safeData.length > 0) {\n                            // Type guard: verify first item has expected Message properties\n                            const firstItem = safeData[0];\n                            if (firstItem && typeof firstItem === 'object' && 'id' in firstItem && 'title' in firstItem) {\n                                console.log('[fetchMessages] Fetched messages (safe columns) sample:', firstItem);\n                                set(()=>({\n                                        messages: safeData\n                                    }));\n                                return;\n                            }\n                        }\n                        if (safeData && Array.isArray(safeData) && safeData.length === 0) {\n                            console.log('[fetchMessages] No messages found');\n                            set(()=>({\n                                    messages: []\n                                }));\n                            return;\n                        }\n                    } catch (retryErr) {\n                        console.error('[fetchMessages] Retry with safe columns failed:', retryErr);\n                        return;\n                    }\n                }\n                if (data && Array.isArray(data) && data.length > 0) {\n                    // Type guard: verify first item has expected Message properties\n                    const firstItem = data[0];\n                    if (firstItem && typeof firstItem === 'object' && 'id' in firstItem && 'title' in firstItem) {\n                        console.log('Fetched messages sample:', firstItem);\n                        set(()=>({\n                                messages: data\n                            }));\n                        return;\n                    }\n                }\n                if (data && Array.isArray(data) && data.length === 0) {\n                    console.log('[fetchMessages] No messages found (initial fetch)');\n                    set(()=>({\n                            messages: []\n                        }));\n                }\n            } catch (error) {\n                console.error('Error fetching messages:', error);\n            }\n        },\n        // Group Actions\n        addGroup: async (groupData)=>{\n            try {\n                const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('groups').insert([\n                    groupData\n                ]).select();\n                if (error) throw error;\n                if (data) {\n                    set((state)=>({\n                            groups: [\n                                ...state.groups,\n                                ...data\n                            ]\n                        }));\n                }\n            } catch (error) {\n                console.error('Error adding group:', error);\n                const newGroup = {\n                    ...groupData,\n                    id: Math.max(...get().groups.map((g)=>g.id), 0) + 1,\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                };\n                set((state)=>({\n                        groups: [\n                            ...state.groups,\n                            newGroup\n                        ]\n                    }));\n            }\n        },\n        updateGroup: async (id, groupData)=>{\n            try {\n                const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('groups').update({\n                    ...groupData,\n                    updated_at: new Date().toISOString()\n                }).eq('id', id);\n                if (error) throw error;\n                set((state)=>({\n                        groups: state.groups.map((group)=>group.id === id ? {\n                                ...group,\n                                ...groupData,\n                                updated_at: new Date().toISOString()\n                            } : group)\n                    }));\n            } catch (error) {\n                console.error('Error updating group:', error);\n                set((state)=>({\n                        groups: state.groups.map((group)=>group.id === id ? {\n                                ...group,\n                                ...groupData,\n                                updated_at: new Date().toISOString()\n                            } : group)\n                    }));\n            }\n        },\n        deleteGroup: async (id)=>{\n            try {\n                const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('groups').delete().eq('id', id);\n                if (error) throw error;\n                set((state)=>({\n                        groups: state.groups.filter((group)=>group.id !== id)\n                    }));\n            } catch (error) {\n                console.error('Error deleting group:', error);\n                set((state)=>({\n                        groups: state.groups.filter((group)=>group.id !== id)\n                    }));\n            }\n        },\n        fetchGroups: async ()=>{\n            try {\n                const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('groups').select('*').order('created_at', {\n                    ascending: false\n                });\n                if (error) throw error;\n                if (data) {\n                    set(()=>({\n                            groups: data\n                        }));\n                }\n            } catch (error) {\n                console.error('Error fetching groups:', error);\n            }\n        },\n        // Department Actions\n        addDepartment: async (departmentData)=>{\n            try {\n                const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('departments').insert([\n                    departmentData\n                ]).select();\n                if (error) {\n                    console.error('Supabase error adding department:', error);\n                    throw error;\n                }\n                if (data) {\n                    set((state)=>({\n                            departments: [\n                                ...state.departments,\n                                ...data\n                            ]\n                        }));\n                    return data[0];\n                }\n                return null;\n            } catch (error) {\n                console.error('Error adding department:', error);\n                // Fallback to local state if Supabase fails\n                const newDepartment = {\n                    ...departmentData,\n                    id: Math.max(...get().departments.map((d)=>d.id), 0) + 1,\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                };\n                set((state)=>({\n                        departments: [\n                            ...state.departments,\n                            newDepartment\n                        ]\n                    }));\n                return newDepartment;\n            }\n        },\n        updateDepartment: async (id, departmentData)=>{\n            try {\n                // Get the old department name before updating\n                const state = get();\n                const oldDepartment = state.departments.find((d)=>d.id === id);\n                const oldDeptName = oldDepartment === null || oldDepartment === void 0 ? void 0 : oldDepartment.name;\n                const newDeptName = departmentData.name;\n                console.log('Updating department: \"'.concat(oldDeptName, '\" → \"').concat(newDeptName, '\"'));\n                // Update the department in Supabase\n                const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('departments').update({\n                    ...departmentData,\n                    updated_at: new Date().toISOString()\n                }).eq('id', id);\n                if (error) {\n                    console.warn('Error updating department in Supabase:', error);\n                }\n                // If department name changed, update all users with the old department name\n                if (oldDeptName && newDeptName && oldDeptName !== newDeptName) {\n                    console.log('Updating users with department: \"'.concat(oldDeptName, '\"'));\n                    // Update in Supabase\n                    const { error: usersError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('users').update({\n                        department: newDeptName,\n                        updated_at: new Date().toISOString()\n                    }).eq('department', oldDeptName);\n                    if (usersError) {\n                        console.warn('Error updating users with new department name:', usersError);\n                    } else {\n                        console.log(\"Successfully updated users in Supabase\");\n                    }\n                }\n                // Update local state\n                set((state)=>{\n                    const updatedUsers = state.users.map((user)=>{\n                        if (user.department === oldDeptName && newDeptName) {\n                            console.log(\"Updating user \".concat(user.name, ': \"').concat(user.department, '\" → \"').concat(newDeptName, '\"'));\n                            return {\n                                ...user,\n                                department: newDeptName,\n                                updated_at: new Date().toISOString()\n                            };\n                        }\n                        return user;\n                    });\n                    return {\n                        departments: state.departments.map((department)=>department.id === id ? {\n                                ...department,\n                                ...departmentData,\n                                updated_at: new Date().toISOString()\n                            } : department),\n                        users: updatedUsers\n                    };\n                });\n            } catch (error) {\n                console.error('Error updating department:', error);\n                // Fallback to local state update\n                set((state)=>{\n                    var _state_departments_find;\n                    const oldDeptName = (_state_departments_find = state.departments.find((d)=>d.id === id)) === null || _state_departments_find === void 0 ? void 0 : _state_departments_find.name;\n                    const newDeptName = departmentData.name;\n                    return {\n                        departments: state.departments.map((department)=>department.id === id ? {\n                                ...department,\n                                ...departmentData,\n                                updated_at: new Date().toISOString()\n                            } : department),\n                        users: state.users.map((user)=>user.department === oldDeptName && newDeptName ? {\n                                ...user,\n                                department: newDeptName\n                            } : user)\n                    };\n                });\n            }\n        },\n        deleteDepartment: async (id)=>{\n            try {\n                const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('departments').delete().eq('id', id);\n                if (error) throw error;\n                set((state)=>({\n                        departments: state.departments.filter((department)=>department.id !== id)\n                    }));\n            } catch (error) {\n                console.error('Error deleting department:', error);\n                // Fallback to local state\n                set((state)=>({\n                        departments: state.departments.filter((department)=>department.id !== id)\n                    }));\n            }\n        },\n        fetchDepartments: async ()=>{\n            try {\n                const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('departments').select('*').order('created_at', {\n                    ascending: false\n                });\n                if (error) throw error;\n                if (data) {\n                    set(()=>({\n                            departments: data\n                        }));\n                }\n            } catch (error) {\n                console.error('Error fetching departments:', error);\n            // Keep existing local departments if fetch fails\n            }\n        },\n        // Notification Actions\n        addNotification: async (notificationData)=>{\n            try {\n                // Dedup: check local state first\n                const existsLocally = get().notifications.some((n)=>n.message_id === notificationData.message_id && n.user_id === notificationData.user_id);\n                if (existsLocally) {\n                    console.info('Notification dedup: found locally, skipping', notificationData);\n                    return;\n                }\n                // Check Supabase for existing notification for same message + user\n                try {\n                    const { data: existing, error: selectError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('notifications').select('*').eq('message_id', notificationData.message_id).eq('user_id', notificationData.user_id).limit(1);\n                    if (selectError) {\n                        console.warn('Supabase select error while checking notifications dedup:', selectError.message || selectError);\n                    } else if (existing && existing.length > 0) {\n                        console.info('Notification dedup: found in Supabase, skipping', notificationData);\n                        return;\n                    }\n                } catch (err) {\n                    console.warn('Supabase not available when checking notification dedup, continuing with local only check');\n                }\n                // Try to persist to Supabase\n                try {\n                    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('notifications').insert([\n                        notificationData\n                    ]).select().single();\n                    if (error) {\n                        console.warn('Supabase insert error for notification, falling back to local:', error.message || error);\n                    }\n                    if (data) {\n                        // Use returned Supabase row to maintain consistent ids/created_at\n                        set((state)=>({\n                                notifications: [\n                                    data,\n                                    ...state.notifications\n                                ]\n                            }));\n                        return;\n                    }\n                } catch (supabaseError) {\n                    console.warn('Supabase unavailable when inserting notification, will add locally');\n                }\n                // Fallback/local insertion\n                const newNotification = {\n                    ...notificationData,\n                    id: Math.max(...get().notifications.map((n)=>n.id), 0) + 1,\n                    created_at: new Date().toISOString()\n                };\n                set((state)=>({\n                        notifications: [\n                            newNotification,\n                            ...state.notifications\n                        ]\n                    }));\n            } catch (error) {\n                console.error('Failed to add notification:', error);\n                throw error;\n            }\n        },\n        markNotificationAsRead: (id)=>{\n            set((state)=>({\n                    notifications: state.notifications.map((notif)=>notif.id === id ? {\n                            ...notif,\n                            read: true\n                        } : notif)\n                }));\n        },\n        markNotificationsAsReadForMessage: (messageId)=>{\n            set((state)=>({\n                    notifications: state.notifications.map((notif)=>notif.message_id === messageId ? {\n                            ...notif,\n                            read: true\n                        } : notif)\n                }));\n        },\n        getUnreadNotifications: ()=>{\n            const { notifications, currentUser } = get();\n            return notifications.filter((n)=>n.user_id === (currentUser === null || currentUser === void 0 ? void 0 : currentUser.id) && !n.read);\n        },\n        // Comment Actions\n        fetchComments: async ()=>{\n            try {\n                const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('comments').select('*').order('created_at', {\n                    ascending: true\n                });\n                if (error) {\n                    console.warn('Error fetching comments from Supabase:', error);\n                } else if (data) {\n                    set(()=>({\n                            comments: data\n                        }));\n                }\n            } catch (error) {\n                console.error('Error fetching comments:', error);\n            }\n        },\n        addComment: async (commentData)=>{\n            try {\n                // Try Supabase insert first\n                let savedComment = null;\n                try {\n                    const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('comments').insert([\n                        commentData\n                    ]).select().single();\n                    if (error) {\n                        console.warn('Supabase insert comment failed, falling back to local', error);\n                    } else {\n                        savedComment = data;\n                    }\n                } catch (supabaseError) {\n                    console.warn('Supabase unavailable for comments, will use local state', supabaseError);\n                }\n                const newComment = savedComment || {\n                    id: Math.max(...get().comments.map((c)=>c.id), 0) + 1,\n                    ...commentData,\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                };\n                // Add to local state\n                set((state)=>({\n                        comments: [\n                            ...state.comments,\n                            newComment\n                        ]\n                    }));\n                // Notify message sender (if not the commenter)\n                try {\n                    const message = get().messages.find((m)=>m.id === newComment.message_id);\n                    const currentUser = get().currentUser;\n                    if (message && currentUser && message.sender !== currentUser.email) {\n                        var _get_users_find;\n                        await get().addNotification({\n                            message_id: message.id,\n                            user_id: message.sender && ((_get_users_find = get().users.find((u)=>u.email === message.sender)) === null || _get_users_find === void 0 ? void 0 : _get_users_find.id) ? get().users.find((u)=>u.email === message.sender).id : 0,\n                            message: \"New comment on: \".concat(message.title),\n                            read: false\n                        });\n                    }\n                } catch (notifyErr) {\n                    console.warn('Failed to create notification for comment:', notifyErr);\n                }\n                // Handle role mentions like @staff or @students\n                try {\n                    const mentions = (newComment.content || '').match(/@(staff|students|admins)\\b/g);\n                    if (mentions && mentions.length > 0) {\n                        const roles = Array.from(new Set(mentions.map((m)=>m.replace('@', ''))));\n                        const usersToNotify = [];\n                        for (const role of roles){\n                            if (role === 'staff' || role === 'students' || role === 'admins') {\n                                const roleKey = role === 'students' ? 'student' : role;\n                                usersToNotify.push(...get().users.filter((u)=>u.role === roleKey));\n                            }\n                        }\n                        for (const u of usersToNotify){\n                            await get().addNotification({\n                                message_id: newComment.message_id,\n                                user_id: u.id,\n                                message: \"You were mentioned in a comment\",\n                                read: false\n                            });\n                        }\n                    }\n                } catch (mentionErr) {\n                    console.warn('Failed to create mention notifications:', mentionErr);\n                }\n                return newComment;\n            } catch (error) {\n                console.error('Failed to add comment:', error);\n                throw error;\n            }\n        },\n        updateComment: async (id, commentData)=>{\n            try {\n                // Update local state\n                set((state)=>({\n                        comments: state.comments.map((c)=>c.id === id ? {\n                                ...c,\n                                ...commentData,\n                                updated_at: new Date().toISOString()\n                            } : c)\n                    }));\n                // Try Supabase\n                try {\n                    const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('comments').update({\n                        ...commentData,\n                        updated_at: new Date().toISOString()\n                    }).eq('id', id);\n                    if (error) console.warn('Supabase error updating comment:', error);\n                } catch (supabaseError) {\n                    console.warn('Supabase unavailable when updating comment', supabaseError);\n                }\n            } catch (error) {\n                console.error('Failed to update comment locally:', error);\n            }\n        },\n        deleteComment: async (id)=>{\n            try {\n                // Remove from local state\n                set((state)=>({\n                        comments: state.comments.filter((c)=>c.id !== id)\n                    }));\n                // Try Supabase\n                try {\n                    const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('comments').delete().eq('id', id);\n                    if (error) console.warn('Supabase error deleting comment:', error);\n                } catch (supabaseError) {\n                    console.warn('Supabase unavailable when deleting comment', supabaseError);\n                }\n            } catch (error) {\n                console.error('Failed to delete comment:', error);\n            }\n        },\n        // Course Actions\n        addCourse: async (courseData)=>{\n            try {\n                console.log('[addCourse] Starting with data:', JSON.stringify(courseData, null, 2));\n                // Validate required fields\n                if (!courseData.name) {\n                    throw new Error('Course name is required');\n                }\n                if (!courseData.department_id) {\n                    throw new Error('Department ID is required');\n                }\n                if (!courseData.created_by) {\n                    throw new Error('Created by is required');\n                }\n                // Generate a default code if empty (from course name first letters)\n                const courseCode = courseData.code && courseData.code.trim() ? courseData.code.trim() : courseData.name.split(' ').map((w)=>w[0]).join('').toUpperCase() || 'COURSE';\n                console.log('[addCourse] Validation passed, inserting to Supabase...');\n                const dataToInsert = {\n                    ...courseData,\n                    code: courseCode,\n                    description: courseData.description || null\n                };\n                const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('courses').insert([\n                    dataToInsert\n                ]).select();\n                console.log('[addCourse] Supabase response received');\n                console.log('[addCourse] Data:', data);\n                console.log('[addCourse] Error present:', !!error);\n                if (error) {\n                    console.error('[addCourse] Supabase returned error object');\n                    console.error('[addCourse] Error keys:', Object.keys(error || {}));\n                    // Try to extract error information\n                    let errorMsg = 'Unknown Supabase error';\n                    if (typeof error === 'object' && error !== null) {\n                        if ('message' in error) errorMsg = String(error.message);\n                        if ('code' in error) console.error('[addCourse] Error code:', error.code);\n                        if ('details' in error) console.error('[addCourse] Error details:', error.details);\n                        if ('hint' in error) console.error('[addCourse] Error hint:', error.hint);\n                    }\n                    throw new Error(\"Supabase error: \".concat(errorMsg));\n                }\n                if (data && data.length > 0) {\n                    console.log('[addCourse] Course inserted successfully');\n                    set((state)=>({\n                            courses: [\n                                ...state.courses,\n                                ...data\n                            ]\n                        }));\n                    return data[0];\n                }\n                console.warn('[addCourse] No data returned from insert, but no error either');\n                return null;\n            } catch (error) {\n                var _error_constructor;\n                console.error('[addCourse] Exception caught');\n                console.error('[addCourse] Error type:', typeof error);\n                console.error('[addCourse] Error constructor:', error === null || error === void 0 ? void 0 : (_error_constructor = error.constructor) === null || _error_constructor === void 0 ? void 0 : _error_constructor.name);\n                const errorMessage = error instanceof Error ? error.message : String(error);\n                console.error('[addCourse] Error message:', errorMessage);\n                if (error instanceof Error && error.stack) {\n                    console.error('[addCourse] Stack trace:', error.stack);\n                }\n                console.error('[addCourse] CourseData:', JSON.stringify(courseData, null, 2));\n                // Fallback: add course optimistically to local state\n                try {\n                    const newCourse = {\n                        ...courseData,\n                        id: Math.max(...get().courses.map((c)=>c.id), 0) + 1,\n                        created_at: new Date().toISOString(),\n                        updated_at: new Date().toISOString()\n                    };\n                    console.log('[addCourse] Adding course optimistically');\n                    set((state)=>({\n                            courses: [\n                                ...state.courses,\n                                newCourse\n                            ]\n                        }));\n                    return newCourse;\n                } catch (fallbackError) {\n                    const fallbackMsg = fallbackError instanceof Error ? fallbackError.message : String(fallbackError);\n                    console.error('[addCourse] Fallback failed:', fallbackMsg);\n                    throw error;\n                }\n            }\n        },\n        updateCourse: async (id, courseData)=>{\n            try {\n                const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('courses').update({\n                    ...courseData,\n                    updated_at: new Date().toISOString()\n                }).eq('id', id);\n                if (error) throw error;\n                set((state)=>({\n                        courses: state.courses.map((course)=>course.id === id ? {\n                                ...course,\n                                ...courseData,\n                                updated_at: new Date().toISOString()\n                            } : course)\n                    }));\n            } catch (error) {\n                console.error('Error updating course:', {\n                    message: error instanceof Error ? error.message : String(error),\n                    error,\n                    courseId: id,\n                    courseData\n                });\n                set((state)=>({\n                        courses: state.courses.map((course)=>course.id === id ? {\n                                ...course,\n                                ...courseData,\n                                updated_at: new Date().toISOString()\n                            } : course)\n                    }));\n            }\n        },\n        deleteCourse: async (id)=>{\n            try {\n                const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('courses').delete().eq('id', id);\n                if (error) throw error;\n                set((state)=>({\n                        courses: state.courses.filter((course)=>course.id !== id)\n                    }));\n            } catch (error) {\n                console.error('Error deleting course:', {\n                    message: error instanceof Error ? error.message : String(error),\n                    error,\n                    courseId: id\n                });\n                set((state)=>({\n                        courses: state.courses.filter((course)=>course.id !== id)\n                    }));\n            }\n        },\n        fetchCourses: async ()=>{\n            try {\n                const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('courses').select('*').order('created_at', {\n                    ascending: false\n                });\n                if (error) throw error;\n                if (data) {\n                    set(()=>({\n                            courses: data\n                        }));\n                }\n            } catch (error) {\n                console.error('Error fetching courses:', {\n                    message: error instanceof Error ? error.message : String(error),\n                    error\n                });\n            }\n        },\n        // Sub Course Actions\n        addSubCourse: async (subCourseData)=>{\n            try {\n                const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('sub_courses').insert([\n                    subCourseData\n                ]).select();\n                if (error) throw error;\n                if (data) {\n                    set((state)=>({\n                            subCourses: [\n                                ...state.subCourses,\n                                ...data\n                            ]\n                        }));\n                }\n            } catch (error) {\n                console.error('Error adding sub course:', error);\n                const newSubCourse = {\n                    ...subCourseData,\n                    id: Math.max(...get().subCourses.map((sc)=>sc.id), 0) + 1,\n                    created_at: new Date().toISOString(),\n                    updated_at: new Date().toISOString()\n                };\n                set((state)=>({\n                        subCourses: [\n                            ...state.subCourses,\n                            newSubCourse\n                        ]\n                    }));\n            }\n        },\n        updateSubCourse: async (id, subCourseData)=>{\n            try {\n                const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('sub_courses').update({\n                    ...subCourseData,\n                    updated_at: new Date().toISOString()\n                }).eq('id', id);\n                if (error) throw error;\n                set((state)=>({\n                        subCourses: state.subCourses.map((subCourse)=>subCourse.id === id ? {\n                                ...subCourse,\n                                ...subCourseData,\n                                updated_at: new Date().toISOString()\n                            } : subCourse)\n                    }));\n            } catch (error) {\n                console.error('Error updating sub course:', error);\n                set((state)=>({\n                        subCourses: state.subCourses.map((subCourse)=>subCourse.id === id ? {\n                                ...subCourse,\n                                ...subCourseData,\n                                updated_at: new Date().toISOString()\n                            } : subCourse)\n                    }));\n            }\n        },\n        deleteSubCourse: async (id)=>{\n            try {\n                const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('sub_courses').delete().eq('id', id);\n                if (error) throw error;\n                set((state)=>({\n                        subCourses: state.subCourses.filter((subCourse)=>subCourse.id !== id)\n                    }));\n            } catch (error) {\n                console.error('Error deleting sub course:', error);\n                set((state)=>({\n                        subCourses: state.subCourses.filter((subCourse)=>subCourse.id !== id)\n                    }));\n            }\n        },\n        fetchSubCourses: async ()=>{\n            try {\n                const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('sub_courses').select('*').order('created_at', {\n                    ascending: false\n                });\n                if (error) throw error;\n                if (data) {\n                    set(()=>({\n                            subCourses: data\n                        }));\n                }\n            } catch (error) {\n                console.error('Error fetching sub courses:', error);\n            }\n        }\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQyxlQUNMQyxNQUFNLENBQUMsS0FDUHNDLEtBQUssQ0FBQyxjQUFjO29CQUFFQyxXQUFXO2dCQUFNO2dCQUUxQyxJQUFJekMsT0FBTyxNQUFNQTtnQkFFakIsSUFBSUQsTUFBTTtvQkFDUmpCLElBQUksSUFBTzs0QkFBRVUsWUFBWU87d0JBQUs7Z0JBQ2hDO1lBQ0YsRUFBRSxPQUFPQyxPQUFPO2dCQUNkTyxRQUFRUCxLQUFLLENBQUMsK0JBQStCQTtZQUMvQztRQUNGO0lBQ0YsSUFBRyIsInNvdXJjZXMiOlsiRDpcXEdvb2dsZVxcY2FtcHVzLW1lc3NhZ2luZy1wb3J0YWxcXGxpYlxcc3RvcmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCdcclxuaW1wb3J0IHR5cGUgeyBOb3RpZmljYXRpb24sIENvdXJzZSwgU3ViQ291cnNlIH0gZnJvbSAnLi9zdXBhYmFzZSdcclxuaW1wb3J0IHsgVXNlciwgTWVzc2FnZSwgR3JvdXAsIERlcGFydG1lbnQsIHN1cGFiYXNlIH0gZnJvbSAnLi9zdXBhYmFzZSdcclxuXHJcbmludGVyZmFjZSBBcHBTdGF0ZSB7XHJcbiAgLy8gQXV0aGVudGljYXRpb25cclxuICBjdXJyZW50VXNlcjogVXNlciB8IG51bGxcclxuICBpc0F1dGhlbnRpY2F0ZWQ6IGJvb2xlYW5cclxuXHJcbiAgLy8gVGhlbWVcclxuICBpc0RhcmtNb2RlOiBib29sZWFuXHJcblxyXG4gIC8vIFVzZXJzXHJcbiAgdXNlcnM6IFVzZXJbXVxyXG5cclxuICAvLyBNZXNzYWdlc1xyXG4gIG1lc3NhZ2VzOiBNZXNzYWdlW11cclxuXHJcbiAgLy8gR3JvdXBzXHJcbiAgZ3JvdXBzOiBHcm91cFtdXHJcblxyXG4gIC8vIERlcGFydG1lbnRzXHJcbiAgZGVwYXJ0bWVudHM6IERlcGFydG1lbnRbXVxyXG5cclxuICAvLyBDb3Vyc2VzXHJcbiAgY291cnNlczogQ291cnNlW11cclxuXHJcbiAgLy8gU3ViIENvdXJzZXNcclxuICBzdWJDb3Vyc2VzOiBTdWJDb3Vyc2VbXVxyXG5cclxuICAvLyBDb3Vyc2UgQWN0aW9uc1xyXG4gIGFkZENvdXJzZTogKGNvdXJzZTogT21pdDxDb3Vyc2UsICdpZCcgfCAnY3JlYXRlZF9hdCcgfCAndXBkYXRlZF9hdCc+KSA9PiBQcm9taXNlPENvdXJzZSB8IG51bGw+XHJcbiAgdXBkYXRlQ291cnNlOiAoaWQ6IG51bWJlciwgY291cnNlOiBQYXJ0aWFsPENvdXJzZT4pID0+IFByb21pc2U8dm9pZD5cclxuICBkZWxldGVDb3Vyc2U6IChpZDogbnVtYmVyKSA9PiBQcm9taXNlPHZvaWQ+XHJcbiAgZmV0Y2hDb3Vyc2VzOiAoKSA9PiBQcm9taXNlPHZvaWQ+XHJcblxyXG4gIC8vIFN1YiBDb3Vyc2UgQWN0aW9uc1xyXG4gIGFkZFN1YkNvdXJzZTogKHN1YkNvdXJzZTogT21pdDxTdWJDb3Vyc2UsICdpZCcgfCAnY3JlYXRlZF9hdCcgfCAndXBkYXRlZF9hdCc+KSA9PiBQcm9taXNlPHZvaWQ+XHJcbiAgdXBkYXRlU3ViQ291cnNlOiAoaWQ6IG51bWJlciwgc3ViQ291cnNlOiBQYXJ0aWFsPFN1YkNvdXJzZT4pID0+IFByb21pc2U8dm9pZD5cclxuICBkZWxldGVTdWJDb3Vyc2U6IChpZDogbnVtYmVyKSA9PiBQcm9taXNlPHZvaWQ+XHJcbiAgZmV0Y2hTdWJDb3Vyc2VzOiAoKSA9PiBQcm9taXNlPHZvaWQ+XHJcblxyXG4gIC8vIE5vdGlmaWNhdGlvbnNcclxuICBub3RpZmljYXRpb25zOiBOb3RpZmljYXRpb25bXVxyXG4gIC8vIENvbW1lbnRzXHJcbiAgY29tbWVudHM6IENvbW1lbnRbXVxyXG5cclxuICAvLyBBY3Rpb25zXHJcbiAgbG9naW46IChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nLCByb2xlPzogc3RyaW5nKSA9PiBQcm9taXNlPGJvb2xlYW4+XHJcbiAgbG9nb3V0OiAoKSA9PiB2b2lkXHJcbiAgdG9nZ2xlVGhlbWU6ICgpID0+IHZvaWRcclxuXHJcbiAgLy8gVXNlciBBY3Rpb25zXHJcbiAgYWRkVXNlcjogKHVzZXI6IE9taXQ8VXNlciwgJ2lkJyB8ICdjcmVhdGVkX2F0JyB8ICd1cGRhdGVkX2F0Jz4pID0+IFByb21pc2U8dm9pZD5cclxuICB1cGRhdGVVc2VyOiAoaWQ6IG51bWJlciwgdXNlcjogUGFydGlhbDxVc2VyPikgPT4gUHJvbWlzZTx2b2lkPlxyXG4gIGRlbGV0ZVVzZXI6IChpZDogbnVtYmVyKSA9PiBQcm9taXNlPHZvaWQ+XHJcbiAgZmV0Y2hVc2VyczogKCkgPT4gUHJvbWlzZTx2b2lkPlxyXG5cclxuICAvLyBNZXNzYWdlIEFjdGlvbnNcclxuICBhZGRNZXNzYWdlOiAobWVzc2FnZTogT21pdDxNZXNzYWdlLCAnaWQnIHwgJ2NyZWF0ZWRfYXQnIHwgJ3VwZGF0ZWRfYXQnPikgPT4gUHJvbWlzZTx2b2lkPlxyXG4gIC8vIENvbW1lbnQgQWN0aW9uc1xyXG4gIGZldGNoQ29tbWVudHM6ICgpID0+IFByb21pc2U8dm9pZD5cclxuICBhZGRDb21tZW50OiAoY29tbWVudERhdGE6IE9taXQ8Q29tbWVudCwgJ2lkJyB8ICdjcmVhdGVkX2F0JyB8ICd1cGRhdGVkX2F0Jz4pID0+IFByb21pc2U8Q29tbWVudCB8IG51bGw+XHJcbiAgdXBkYXRlQ29tbWVudDogKGlkOiBudW1iZXIsIGNvbW1lbnREYXRhOiBQYXJ0aWFsPENvbW1lbnQ+KSA9PiBQcm9taXNlPHZvaWQ+XHJcbiAgZGVsZXRlQ29tbWVudDogKGlkOiBudW1iZXIpID0+IFByb21pc2U8dm9pZD5cclxuICBhY2tub3dsZWRnZU1lc3NhZ2U6IChtZXNzYWdlSWQ6IG51bWJlciwgdXNlcklkOiBudW1iZXIpID0+IFByb21pc2U8dm9pZD5cclxuICBtYXJrTWVzc2FnZUFzUmVhZDogKG1lc3NhZ2VJZDogbnVtYmVyKSA9PiB2b2lkXHJcbiAgZmV0Y2hNZXNzYWdlczogKCkgPT4gUHJvbWlzZTx2b2lkPlxyXG4gIGdldE1lc3NhZ2VBY2tub3dsZWRnZW1lbnREZXRhaWxzOiAobWVzc2FnZUlkOiBudW1iZXIpID0+IHsgYWNrbm93bGVkZ2VkOiBhbnlbXTsgcGVuZGluZzogYW55W10gfVxyXG5cclxuICAvLyBHcm91cCBBY3Rpb25zXHJcbiAgYWRkR3JvdXA6IChncm91cDogT21pdDxHcm91cCwgJ2lkJyB8ICdjcmVhdGVkX2F0JyB8ICd1cGRhdGVkX2F0Jz4pID0+IFByb21pc2U8dm9pZD5cclxuICB1cGRhdGVHcm91cDogKGlkOiBudW1iZXIsIGdyb3VwOiBQYXJ0aWFsPEdyb3VwPikgPT4gUHJvbWlzZTx2b2lkPlxyXG4gIGRlbGV0ZUdyb3VwOiAoaWQ6IG51bWJlcikgPT4gUHJvbWlzZTx2b2lkPlxyXG4gIGZldGNoR3JvdXBzOiAoKSA9PiBQcm9taXNlPHZvaWQ+XHJcblxyXG4gIC8vIERlcGFydG1lbnQgQWN0aW9uc1xyXG4gIGFkZERlcGFydG1lbnQ6IChkZXBhcnRtZW50OiBPbWl0PERlcGFydG1lbnQsICdpZCcgfCAnY3JlYXRlZF9hdCcgfCAndXBkYXRlZF9hdCc+KSA9PiBQcm9taXNlPERlcGFydG1lbnQgfCBudWxsPlxyXG4gIHVwZGF0ZURlcGFydG1lbnQ6IChpZDogbnVtYmVyLCBkZXBhcnRtZW50OiBQYXJ0aWFsPERlcGFydG1lbnQ+KSA9PiBQcm9taXNlPHZvaWQ+XHJcbiAgZGVsZXRlRGVwYXJ0bWVudDogKGlkOiBudW1iZXIpID0+IFByb21pc2U8dm9pZD5cclxuICBmZXRjaERlcGFydG1lbnRzOiAoKSA9PiBQcm9taXNlPHZvaWQ+XHJcblxyXG4gIC8vIE5vdGlmaWNhdGlvbiBBY3Rpb25zXHJcbiAgYWRkTm90aWZpY2F0aW9uOiAobm90aWZpY2F0aW9uOiBPbWl0PE5vdGlmaWNhdGlvbiwgJ2lkJyB8ICdjcmVhdGVkX2F0Jz4pID0+IFByb21pc2U8dm9pZD5cclxuICBtYXJrTm90aWZpY2F0aW9uQXNSZWFkOiAoaWQ6IG51bWJlcikgPT4gdm9pZFxyXG4gIG1hcmtOb3RpZmljYXRpb25zQXNSZWFkRm9yTWVzc2FnZTogKG1lc3NhZ2VJZDogbnVtYmVyKSA9PiB2b2lkXHJcbiAgZ2V0VW5yZWFkTm90aWZpY2F0aW9uczogKCkgPT4gTm90aWZpY2F0aW9uW11cclxufVxyXG5cclxuLy8gRGVtbyB1c2Vyc1xyXG5jb25zdCBkZW1vVXNlcnM6IFVzZXJbXSA9IFtcclxuICB7XHJcbiAgICBpZDogMSxcclxuICAgIG5hbWU6ICdBZG1pbiBVc2VyJyxcclxuICAgIGVtYWlsOiAnYWRtaW5AY29sbGVnZS5lZHUnLFxyXG4gICAgcGFzc3dvcmQ6ICdhZG1pbjEyMycsXHJcbiAgICByb2xlOiAnYWRtaW4nLFxyXG4gICAgc3RhdHVzOiAnYWN0aXZlJyxcclxuICAgIGRlcGFydG1lbnQ6ICdBZG1pbmlzdHJhdGlvbicsXHJcbiAgICBwaG9uZV9udW1iZXI6ICcxMjM0NTY3ODkwJyxcclxuICAgIGRvYjogJzE5ODUtMDEtMTUnLFxyXG4gICAgYWdlOiAzOSxcclxuICAgIGJsb29kX2dyb3VwOiAnTysnLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6IDIsXHJcbiAgICBuYW1lOiAnU3RhZmYgTWVtYmVyJyxcclxuICAgIGVtYWlsOiAnc3RhZmZAY29sbGVnZS5lZHUnLFxyXG4gICAgcGFzc3dvcmQ6ICdzdGFmZjEyMycsXHJcbiAgICByb2xlOiAnc3RhZmYnLFxyXG4gICAgc3RhdHVzOiAnYWN0aXZlJyxcclxuICAgIGRlcGFydG1lbnQ6ICdDb21wdXRlciBTY2llbmNlJyxcclxuICAgIHBob25lX251bWJlcjogJzA5ODc2NTQzMjEnLFxyXG4gICAgZG9iOiAnMTk5MC0wNS0yMCcsXHJcbiAgICBhZ2U6IDM0LFxyXG4gICAgYmxvb2RfZ3JvdXA6ICdBKycsXHJcbiAgfSxcclxuICB7XHJcbiAgICBpZDogMyxcclxuICAgIG5hbWU6ICdKb2huIFN0dWRlbnQnLFxyXG4gICAgZW1haWw6ICdzdHVkZW50QGNvbGxlZ2UuZWR1JyxcclxuICAgIHBhc3N3b3JkOiAnc3R1ZGVudDEyMycsXHJcbiAgICByb2xlOiAnc3R1ZGVudCcsXHJcbiAgICBzdGF0dXM6ICdhY3RpdmUnLFxyXG4gICAgZGVwYXJ0bWVudDogJ0NvbXB1dGVyIFNjaWVuY2UnLFxyXG4gICAgY291cnNlOiAnQi5UZWNoJyxcclxuICAgIHN1Yl9jb3Vyc2U6ICdDb21wdXRlciBTY2llbmNlJyxcclxuICAgIHBob25lX251bWJlcjogJzExMjIzMzQ0NTUnLFxyXG4gICAgcGFyZW50X3Bob25lOiAnOTk4ODc3NjY1NScsXHJcbiAgICByZXNwb25zaWJsZV9zdGFmZjogJ1N0YWZmIE1lbWJlcicsXHJcbiAgICBkb2I6ICcyMDAzLTA4LTEwJyxcclxuICAgIGFnZTogMjEsXHJcbiAgICBibG9vZF9ncm91cDogJ0IrJyxcclxuICB9LFxyXG4gIHtcclxuICAgIGlkOiA0LFxyXG4gICAgbmFtZTogJ1NhcmFoIEpvaG5zb24nLFxyXG4gICAgZW1haWw6ICdzYXJhaEBjb2xsZWdlLmVkdScsXHJcbiAgICBwYXNzd29yZDogJ3N0dWRlbnQxMjMnLFxyXG4gICAgcm9sZTogJ3N0dWRlbnQnLFxyXG4gICAgc3RhdHVzOiAnYWN0aXZlJyxcclxuICAgIGRlcGFydG1lbnQ6ICdDb21wdXRlciBTY2llbmNlJyxcclxuICAgIGNvdXJzZTogJ0IuVGVjaCcsXHJcbiAgICBzdWJfY291cnNlOiAnQ29tcHV0ZXIgU2NpZW5jZScsXHJcbiAgICBwaG9uZV9udW1iZXI6ICcyMjMzNDQ1NTY2JyxcclxuICAgIHBhcmVudF9waG9uZTogJzg4Nzc2NjU1NDQnLFxyXG4gICAgcmVzcG9uc2libGVfc3RhZmY6ICdTdGFmZiBNZW1iZXInLFxyXG4gICAgZG9iOiAnMjAwMy0wMy0xNScsXHJcbiAgICBhZ2U6IDIxLFxyXG4gICAgYmxvb2RfZ3JvdXA6ICdBLScsXHJcbiAgfSxcclxuICB7XHJcbiAgICBpZDogNSxcclxuICAgIG5hbWU6ICdNaWNoYWVsIEJyb3duJyxcclxuICAgIGVtYWlsOiAnbWljaGFlbEBjb2xsZWdlLmVkdScsXHJcbiAgICBwYXNzd29yZDogJ3N0dWRlbnQxMjMnLFxyXG4gICAgcm9sZTogJ3N0dWRlbnQnLFxyXG4gICAgc3RhdHVzOiAnYWN0aXZlJyxcclxuICAgIGRlcGFydG1lbnQ6ICdFbGVjdHJvbmljcycsXHJcbiAgICBjb3Vyc2U6ICdCLlRlY2gnLFxyXG4gICAgc3ViX2NvdXJzZTogJ0VsZWN0cm9uaWNzJyxcclxuICAgIHBob25lX251bWJlcjogJzMzNDQ1NTY2NzcnLFxyXG4gICAgcGFyZW50X3Bob25lOiAnNzc2NjU1NDQzMycsXHJcbiAgICByZXNwb25zaWJsZV9zdGFmZjogJ1N0YWZmIE1lbWJlcicsXHJcbiAgICBkb2I6ICcyMDAyLTExLTIyJyxcclxuICAgIGFnZTogMjIsXHJcbiAgICBibG9vZF9ncm91cDogJ08tJyxcclxuICB9LFxyXG5dXHJcblxyXG5cclxuXHJcbi8vIERlbW8gZ3JvdXBzXHJcbmNvbnN0IGRlbW9Hcm91cHM6IEdyb3VwW10gPSBbXHJcbiAge1xyXG4gICAgaWQ6IDEsXHJcbiAgICBuYW1lOiAnQ29tcHV0ZXIgU2NpZW5jZSBTdHVkZW50cycsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0FsbCBzdHVkZW50cyBmcm9tIENvbXB1dGVyIFNjaWVuY2UgZGVwYXJ0bWVudCcsXHJcbiAgICBjcmVhdGVkX2J5OiAnYWRtaW5AY29sbGVnZS5lZHUnLFxyXG4gICAgbWVtYmVyczogWydzdHVkZW50QGNvbGxlZ2UuZWR1JywgJ3NhcmFoQGNvbGxlZ2UuZWR1J10sXHJcbiAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6IDIsXHJcbiAgICBuYW1lOiAnQi5UZWNoIDIwMjQgQmF0Y2gnLFxyXG4gICAgZGVzY3JpcHRpb246ICdTdHVkZW50cyBmcm9tIDIwMjQgYmF0Y2gnLFxyXG4gICAgY3JlYXRlZF9ieTogJ2FkbWluQGNvbGxlZ2UuZWR1JyxcclxuICAgIG1lbWJlcnM6IFsnc3R1ZGVudEBjb2xsZWdlLmVkdScsICdzYXJhaEBjb2xsZWdlLmVkdScsICdtaWNoYWVsQGNvbGxlZ2UuZWR1J10sXHJcbiAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMjUgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxyXG4gIH0sXHJcbl1cclxuXHJcbi8vIERlbW8gZGVwYXJ0bWVudHNcclxuY29uc3QgZGVtb0RlcGFydG1lbnRzOiBEZXBhcnRtZW50W10gPSBbXHJcbiAge1xyXG4gICAgaWQ6IDEsXHJcbiAgICBuYW1lOiAnQ29tcHV0ZXIgU2NpZW5jZScsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0RlcGFydG1lbnQgb2YgQ29tcHV0ZXIgU2NpZW5jZSBhbmQgRW5naW5lZXJpbmcnLFxyXG4gICAgaGVhZF9vZl9kZXBhcnRtZW50OiAnRHIuIFNtaXRoJyxcclxuICAgIGNyZWF0ZWRfYnk6ICdhZG1pbkBjb2xsZWdlLmVkdScsXHJcbiAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMzY1ICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSxcclxuICB9LFxyXG4gIHtcclxuICAgIGlkOiAyLFxyXG4gICAgbmFtZTogJ0VsZWN0cm9uaWNzJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnRGVwYXJ0bWVudCBvZiBFbGVjdHJvbmljcyBhbmQgQ29tbXVuaWNhdGlvbicsXHJcbiAgICBoZWFkX29mX2RlcGFydG1lbnQ6ICdEci4gSm9obnNvbicsXHJcbiAgICBjcmVhdGVkX2J5OiAnYWRtaW5AY29sbGVnZS5lZHUnLFxyXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDMwMCAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXHJcbiAgfSxcclxuICB7XHJcbiAgICBpZDogMyxcclxuICAgIG5hbWU6ICdNZWNoYW5pY2FsIEVuZ2luZWVyaW5nJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnRGVwYXJ0bWVudCBvZiBNZWNoYW5pY2FsIEVuZ2luZWVyaW5nJyxcclxuICAgIGhlYWRfb2ZfZGVwYXJ0bWVudDogJ0RyLiBCcm93bicsXHJcbiAgICBjcmVhdGVkX2J5OiAnYWRtaW5AY29sbGVnZS5lZHUnLFxyXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDI1MCAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXHJcbiAgfSxcclxuICB7XHJcbiAgICBpZDogNCxcclxuICAgIG5hbWU6ICdDaXZpbCBFbmdpbmVlcmluZycsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0RlcGFydG1lbnQgb2YgQ2l2aWwgRW5naW5lZXJpbmcnLFxyXG4gICAgaGVhZF9vZl9kZXBhcnRtZW50OiAnRHIuIERhdmlzJyxcclxuICAgIGNyZWF0ZWRfYnk6ICdhZG1pbkBjb2xsZWdlLmVkdScsXHJcbiAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMjAwICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSxcclxuICB9LFxyXG4gIHtcclxuICAgIGlkOiA1LFxyXG4gICAgbmFtZTogJ0FkbWluaXN0cmF0aW9uJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnQWRtaW5pc3RyYXRpdmUgRGVwYXJ0bWVudCcsXHJcbiAgICBoZWFkX29mX2RlcGFydG1lbnQ6ICdQcmluY2lwYWwnLFxyXG4gICAgY3JlYXRlZF9ieTogJ2FkbWluQGNvbGxlZ2UuZWR1JyxcclxuICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKERhdGUubm93KCkgLSA0MDAgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxyXG4gIH0sXHJcbl1cclxuXHJcbmV4cG9ydCBjb25zdCB1c2VTdG9yZSA9IGNyZWF0ZTxBcHBTdGF0ZT4oKHNldCwgZ2V0KSA9PiAoe1xyXG4gIC8vIEluaXRpYWwgU3RhdGVcclxuICBjdXJyZW50VXNlcjogbnVsbCxcclxuICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxyXG4gIGlzRGFya01vZGU6IGZhbHNlLFxyXG4gIHVzZXJzOiBkZW1vVXNlcnMsXHJcbiAgbWVzc2FnZXM6IFtdLFxyXG4gIGdyb3VwczogZGVtb0dyb3VwcyxcclxuICBkZXBhcnRtZW50czogZGVtb0RlcGFydG1lbnRzLFxyXG4gIGNvdXJzZXM6IFtdLFxyXG4gIHN1YkNvdXJzZXM6IFtdLFxyXG4gIG5vdGlmaWNhdGlvbnM6IFtdLFxyXG4gIGNvbW1lbnRzOiBbXSxcclxuXHJcbiAgLy8gQXV0aGVudGljYXRpb24gQWN0aW9uc1xyXG4gIGxvZ2luOiBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZywgcm9sZT86IHN0cmluZykgPT4ge1xyXG4gICAgLy8gRmlyc3QgdHJ5IHRvIGZpbmQgaW4gbG9jYWwgdXNlcnMgKGluY2x1ZGluZyBuZXdseSBhZGRlZCBvbmVzKVxyXG4gICAgbGV0IHVzZXIgPSBnZXQoKS51c2Vycy5maW5kKFxyXG4gICAgICAodSkgPT4gdS5lbWFpbCA9PT0gZW1haWwgJiYgdS5wYXNzd29yZCA9PT0gcGFzc3dvcmQgJiYgdS5zdGF0dXMgPT09ICdhY3RpdmUnXHJcbiAgICApXHJcblxyXG4gICAgLy8gSWYgbm90IGZvdW5kIGxvY2FsbHksIHRyeSB0byBmZXRjaCBmcm9tIFN1cGFiYXNlXHJcbiAgICBpZiAoIXVzZXIpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgLmZyb20oJ3VzZXJzJylcclxuICAgICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgICAgLmVxKCdlbWFpbCcsIGVtYWlsKVxyXG4gICAgICAgICAgLmVxKCdwYXNzd29yZCcsIHBhc3N3b3JkKVxyXG4gICAgICAgICAgLmVxKCdzdGF0dXMnLCAnYWN0aXZlJylcclxuICAgICAgICAgIC5zaW5nbGUoKVxyXG5cclxuICAgICAgICBpZiAoZGF0YSAmJiAhZXJyb3IpIHtcclxuICAgICAgICAgIHVzZXIgPSBkYXRhXHJcbiAgICAgICAgICAvLyBBZGQgdG8gbG9jYWwgc3RhdGVcclxuICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7IHVzZXJzOiBbLi4uc3RhdGUudXNlcnMsIHVzZXIhXSB9KSlcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKHN1cGFiYXNlRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ1N1cGFiYXNlIGxvZ2luIGZhaWxlZCwgdXNpbmcgbG9jYWwgc3RvcmFnZSBvbmx5JylcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFZhbGlkYXRlIHJvbGUgaWYgcHJvdmlkZWRcclxuICAgIGlmICh1c2VyICYmIHJvbGUgJiYgdXNlci5yb2xlICE9PSByb2xlKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgUm9sZSBtaXNtYXRjaDogVXNlciBoYXMgcm9sZSAnJHt1c2VyLnJvbGV9JyBidXQgbG9naW4gYXR0ZW1wdGVkIHdpdGggcm9sZSAnJHtyb2xlfSdgKVxyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh1c2VyKSB7XHJcbiAgICAgIC8vIE5vcm1hbGl6ZSB1c2VyIHNoYXBlIHRvIGF2b2lkIHJ1bnRpbWUgY3Jhc2hlcyB3aGVuIFVJIGV4cGVjdHMgZmllbGRzXHJcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRVc2VyID0ge1xyXG4gICAgICAgIC8vIHByZXNlcnZlIG9yaWdpbmFsIHByb3BlcnRpZXMgZmlyc3RcclxuICAgICAgICAuLi51c2VyLFxyXG4gICAgICAgIC8vIHRoZW4gZW5zdXJlIHJlcXVpcmVkIGZpZWxkcyBleGlzdCBhbmQgaGF2ZSBzYWZlIGRlZmF1bHRzXHJcbiAgICAgICAgaWQ6IHR5cGVvZiAodXNlciBhcyBhbnkpLmlkID09PSAnbnVtYmVyJyA/ICh1c2VyIGFzIGFueSkuaWQgOiBOdW1iZXIoKHVzZXIgYXMgYW55KS5pZCkgfHwgMCxcclxuICAgICAgICBuYW1lOiAodXNlciBhcyBhbnkpLm5hbWUgfHwgKHVzZXIgYXMgYW55KS5mdWxsX25hbWUgfHwgKHVzZXIgYXMgYW55KS5lbWFpbCB8fCAnVW5rbm93biBVc2VyJyxcclxuICAgICAgICBlbWFpbDogKHVzZXIgYXMgYW55KS5lbWFpbCB8fCAnJyxcclxuICAgICAgICByb2xlOiAodXNlciBhcyBhbnkpLnJvbGUgfHwgJ3N0dWRlbnQnLFxyXG4gICAgICAgIHN0YXR1czogKHVzZXIgYXMgYW55KS5zdGF0dXMgfHwgJ2FjdGl2ZScsXHJcbiAgICAgICAgZGVwYXJ0bWVudDogKHVzZXIgYXMgYW55KS5kZXBhcnRtZW50IHx8ICdOL0EnLFxyXG4gICAgICAgIHBob25lX251bWJlcjogKHVzZXIgYXMgYW55KS5waG9uZV9udW1iZXIgfHwgJycsXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghbm9ybWFsaXplZFVzZXIuaWQpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0xvZ2luOiB1c2VyIGhhcyBubyBudW1lcmljIGlkLCBhc3NpZ25lZCBmYWxsYmFjayBpZCAwLiBUaGlzIG1heSBpbmRpY2F0ZSBpbmNvbnNpc3RlbnQgdXNlciBzY2hlbWEuJylcclxuICAgICAgfVxyXG5cclxuICAgICAgc2V0KHsgY3VycmVudFVzZXI6IG5vcm1hbGl6ZWRVc2VyIGFzIGFueSwgaXNBdXRoZW50aWNhdGVkOiB0cnVlIH0pXHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSlcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpXHJcbiAgfSxcclxuXHJcbiAgbG9nb3V0OiAoKSA9PiB7XHJcbiAgICBzZXQoeyBjdXJyZW50VXNlcjogbnVsbCwgaXNBdXRoZW50aWNhdGVkOiBmYWxzZSB9KVxyXG4gIH0sXHJcblxyXG4gIHRvZ2dsZVRoZW1lOiAoKSA9PiB7XHJcbiAgICBjb25zdCBuZXdUaGVtZSA9ICFnZXQoKS5pc0RhcmtNb2RlXHJcbiAgICBzZXQoeyBpc0RhcmtNb2RlOiBuZXdUaGVtZSB9KVxyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3RoZW1lJywgbmV3VGhlbWUgPyAnZGFyaycgOiAnbGlnaHQnKVxyXG5cclxuICAgIGlmIChuZXdUaGVtZSkge1xyXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZGFyaycpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZGFyaycpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gVXNlciBBY3Rpb25zXHJcbiAgYWRkVXNlcjogYXN5bmMgKHVzZXJEYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBTYXZlIHRvIGxvY2FsIHN0YXRlIGZpcnN0XHJcbiAgICAgIGNvbnN0IG5ld1VzZXI6IFVzZXIgPSB7XHJcbiAgICAgICAgLi4udXNlckRhdGEsXHJcbiAgICAgICAgaWQ6IE1hdGgubWF4KC4uLmdldCgpLnVzZXJzLm1hcCh1ID0+IHUuaWQpLCAwKSArIDEsXHJcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgfVxyXG4gICAgICBzZXQoKHN0YXRlKSA9PiAoeyB1c2VyczogWy4uLnN0YXRlLnVzZXJzLCBuZXdVc2VyXSB9KSlcclxuXHJcbiAgICAgIC8vIFRyeSB0byBzYXZlIHRvIFN1cGFiYXNlXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgIC5mcm9tKCd1c2VycycpXHJcbiAgICAgICAgICAuaW5zZXJ0KFt7XHJcbiAgICAgICAgICAgIG5hbWU6IHVzZXJEYXRhLm5hbWUsXHJcbiAgICAgICAgICAgIGVtYWlsOiB1c2VyRGF0YS5lbWFpbCxcclxuICAgICAgICAgICAgcGFzc3dvcmQ6IHVzZXJEYXRhLnBhc3N3b3JkLFxyXG4gICAgICAgICAgICByb2xlOiB1c2VyRGF0YS5yb2xlLFxyXG4gICAgICAgICAgICBzdGF0dXM6IHVzZXJEYXRhLnN0YXR1cyxcclxuICAgICAgICAgICAgcGhvbmVfbnVtYmVyOiB1c2VyRGF0YS5waG9uZV9udW1iZXIsXHJcbiAgICAgICAgICAgIGRlcGFydG1lbnQ6IHVzZXJEYXRhLmRlcGFydG1lbnQsXHJcbiAgICAgICAgICAgIGNvdXJzZTogdXNlckRhdGEuY291cnNlLFxyXG4gICAgICAgICAgICBzdWJfY291cnNlOiB1c2VyRGF0YS5zdWJfY291cnNlLFxyXG4gICAgICAgICAgICBkb2I6IHVzZXJEYXRhLmRvYixcclxuICAgICAgICAgICAgYWdlOiB1c2VyRGF0YS5hZ2UsXHJcbiAgICAgICAgICAgIGJsb29kX2dyb3VwOiB1c2VyRGF0YS5ibG9vZF9ncm91cCxcclxuICAgICAgICAgICAgcGFyZW50X3Bob25lOiB1c2VyRGF0YS5wYXJlbnRfcGhvbmUsXHJcbiAgICAgICAgICAgIHJlc3BvbnNpYmxlX3N0YWZmOiB1c2VyRGF0YS5yZXNwb25zaWJsZV9zdGFmZixcclxuICAgICAgICAgIH1dKVxyXG4gICAgICAgICAgLnNlbGVjdCgpXHJcbiAgICAgICAgICAuc2luZ2xlKClcclxuXHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1N1cGFiYXNlIG5vdCBjb25maWd1cmVkIG9yIGVycm9yIG9jY3VycmVkLCB1c2luZyBsb2NhbCBzdG9yYWdlOicsIGVycm9yLm1lc3NhZ2UpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdVc2VyIHNhdmVkIHRvIFN1cGFiYXNlIHN1Y2Nlc3NmdWxseScpXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChzdXBhYmFzZUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdTdXBhYmFzZSBub3QgYXZhaWxhYmxlLCB1c2luZyBsb2NhbCBzdG9yYWdlIG9ubHknKVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gYWRkIHVzZXI6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlVXNlcjogYXN5bmMgKGlkLCB1c2VyRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVXBkYXRlIGxvY2FsIHN0YXRlXHJcbiAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgdXNlcnM6IHN0YXRlLnVzZXJzLm1hcCgodXNlcikgPT5cclxuICAgICAgICAgIHVzZXIuaWQgPT09IGlkXHJcbiAgICAgICAgICAgID8geyAuLi51c2VyLCAuLi51c2VyRGF0YSwgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH1cclxuICAgICAgICAgICAgOiB1c2VyXHJcbiAgICAgICAgKSxcclxuICAgICAgfSkpXHJcblxyXG4gICAgICAvLyBUcnkgdG8gdXBkYXRlIGluIFN1cGFiYXNlXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgIC5mcm9tKCd1c2VycycpXHJcbiAgICAgICAgICAudXBkYXRlKHtcclxuICAgICAgICAgICAgbmFtZTogdXNlckRhdGEubmFtZSxcclxuICAgICAgICAgICAgZW1haWw6IHVzZXJEYXRhLmVtYWlsLFxyXG4gICAgICAgICAgICBwYXNzd29yZDogdXNlckRhdGEucGFzc3dvcmQsXHJcbiAgICAgICAgICAgIHJvbGU6IHVzZXJEYXRhLnJvbGUsXHJcbiAgICAgICAgICAgIHN0YXR1czogdXNlckRhdGEuc3RhdHVzLFxyXG4gICAgICAgICAgICBwaG9uZV9udW1iZXI6IHVzZXJEYXRhLnBob25lX251bWJlcixcclxuICAgICAgICAgICAgZGVwYXJ0bWVudDogdXNlckRhdGEuZGVwYXJ0bWVudCxcclxuICAgICAgICAgICAgY291cnNlOiB1c2VyRGF0YS5jb3Vyc2UsXHJcbiAgICAgICAgICAgIHN1Yl9jb3Vyc2U6IHVzZXJEYXRhLnN1Yl9jb3Vyc2UsXHJcbiAgICAgICAgICAgIGRvYjogdXNlckRhdGEuZG9iLFxyXG4gICAgICAgICAgICBhZ2U6IHVzZXJEYXRhLmFnZSxcclxuICAgICAgICAgICAgYmxvb2RfZ3JvdXA6IHVzZXJEYXRhLmJsb29kX2dyb3VwLFxyXG4gICAgICAgICAgICBwYXJlbnRfcGhvbmU6IHVzZXJEYXRhLnBhcmVudF9waG9uZSxcclxuICAgICAgICAgICAgcmVzcG9uc2libGVfc3RhZmY6IHVzZXJEYXRhLnJlc3BvbnNpYmxlX3N0YWZmLFxyXG4gICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLmVxKCdpZCcsIGlkKVxyXG4gICAgICAgICAgLnNlbGVjdCgpXHJcblxyXG4gICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdTdXBhYmFzZSBub3QgY29uZmlndXJlZCBvciBlcnJvciBvY2N1cnJlZCwgdXNpbmcgbG9jYWwgc3RvcmFnZTonLCBlcnJvci5tZXNzYWdlKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNlciB1cGRhdGVkIGluIFN1cGFiYXNlIHN1Y2Nlc3NmdWxseScpXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChzdXBhYmFzZUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdTdXBhYmFzZSBub3QgYXZhaWxhYmxlLCB1c2luZyBsb2NhbCBzdG9yYWdlIG9ubHknKVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIHVzZXI6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZGVsZXRlVXNlcjogYXN5bmMgKGlkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBEZWxldGUgZnJvbSBsb2NhbCBzdGF0ZVxyXG4gICAgICBzZXQoKHN0YXRlKSA9PiAoe1xyXG4gICAgICAgIHVzZXJzOiBzdGF0ZS51c2Vycy5maWx0ZXIoKHVzZXIpID0+IHVzZXIuaWQgIT09IGlkKSxcclxuICAgICAgfSkpXHJcblxyXG4gICAgICAvLyBUcnkgdG8gZGVsZXRlIGZyb20gU3VwYWJhc2VcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgLmZyb20oJ3VzZXJzJylcclxuICAgICAgICAgIC5kZWxldGUoKVxyXG4gICAgICAgICAgLmVxKCdpZCcsIGlkKVxyXG5cclxuICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybignU3VwYWJhc2Ugbm90IGNvbmZpZ3VyZWQgb3IgZXJyb3Igb2NjdXJyZWQsIHVzaW5nIGxvY2FsIHN0b3JhZ2U6JywgZXJyb3IubWVzc2FnZSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgZGVsZXRlZCBmcm9tIFN1cGFiYXNlIHN1Y2Nlc3NmdWxseScpXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChzdXBhYmFzZUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdTdXBhYmFzZSBub3QgYXZhaWxhYmxlLCB1c2luZyBsb2NhbCBzdG9yYWdlIG9ubHknKVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIHVzZXI6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZmV0Y2hVc2VyczogYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgndXNlcnMnKVxyXG4gICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG5cclxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG5cclxuICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICBzZXQoKCkgPT4gKHsgdXNlcnM6IGRhdGEgfSkpXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHVzZXJzOicsIGVycm9yKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIE1lc3NhZ2UgQWN0aW9uc1xyXG4gIGFkZE1lc3NhZ2U6IGFzeW5jIChtZXNzYWdlRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVHJ5IHRvIHNhdmUgdG8gU3VwYWJhc2UgZmlyc3RcclxuICAgICAgbGV0IHN1cGFiYXNlTWVzc2FnZTogTWVzc2FnZSB8IG51bGwgPSBudWxsXHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIEF0dGVtcHQgMTogVHJ5IHRvIGluc2VydCB3aXRoIHJlYWRfYnkgKG5ldyBzY2hlbWEpXHJcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgIC5mcm9tKCdtZXNzYWdlcycpXHJcbiAgICAgICAgICAuaW5zZXJ0KFt7XHJcbiAgICAgICAgICAgIHRpdGxlOiBtZXNzYWdlRGF0YS50aXRsZSxcclxuICAgICAgICAgICAgY29udGVudDogbWVzc2FnZURhdGEuY29udGVudCxcclxuICAgICAgICAgICAgc2VuZGVyOiBtZXNzYWdlRGF0YS5zZW5kZXIsXHJcbiAgICAgICAgICAgIHNlbmRlcl9yb2xlOiBtZXNzYWdlRGF0YS5zZW5kZXJfcm9sZSxcclxuICAgICAgICAgICAgcmVjaXBpZW50czogbWVzc2FnZURhdGEucmVjaXBpZW50cyxcclxuICAgICAgICAgICAgY3VzdG9tX2dyb3VwczogbWVzc2FnZURhdGEuY3VzdG9tX2dyb3VwcyxcclxuICAgICAgICAgICAgcHJpb3JpdHk6IG1lc3NhZ2VEYXRhLnByaW9yaXR5LFxyXG4gICAgICAgICAgICBhdHRhY2htZW50czogbWVzc2FnZURhdGEuYXR0YWNobWVudHMsXHJcbiAgICAgICAgICAgIHNjaGVkdWxlX3R5cGU6IG1lc3NhZ2VEYXRhLnNjaGVkdWxlX3R5cGUsXHJcbiAgICAgICAgICAgIHNjaGVkdWxlX2RhdGU6IG1lc3NhZ2VEYXRhLnNjaGVkdWxlX2RhdGUsXHJcbiAgICAgICAgICAgIHNjaGVkdWxlX3RpbWU6IG1lc3NhZ2VEYXRhLnNjaGVkdWxlX3RpbWUsXHJcbiAgICAgICAgICAgIHRvdGFsX3JlY2lwaWVudHM6IG1lc3NhZ2VEYXRhLnRvdGFsX3JlY2lwaWVudHMsXHJcbiAgICAgICAgICAgIHJlYWRfY291bnQ6IDAsXHJcbiAgICAgICAgICAgIHJlYWRfYnk6IFtdLFxyXG4gICAgICAgICAgICBhY2tub3dsZWRnZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBhY2tub3dsZWRnZWRfYnk6IFtdLFxyXG4gICAgICAgICAgfV0pXHJcbiAgICAgICAgICAuc2VsZWN0KClcclxuICAgICAgICAgIC5zaW5nbGUoKVxyXG5cclxuICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgIC8vIElmIGVycm9yIGlzIGFib3V0IG1pc3NpbmcgY29sdW1uLCB0cnkgZmFsbGJhY2tcclxuICAgICAgICAgIGNvbnNvbGUud2FybignU3VwYWJhc2UgaW5zZXJ0IHdpdGggcmVhZF9ieSBmYWlsZWQsIHJldHJ5aW5nIHdpdGhvdXQgaXQ6JywgZXJyb3IubWVzc2FnZSlcclxuXHJcbiAgICAgICAgICBjb25zdCB7IGRhdGE6IHJldHJ5RGF0YSwgZXJyb3I6IHJldHJ5RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgICAgIC5mcm9tKCdtZXNzYWdlcycpXHJcbiAgICAgICAgICAgIC5pbnNlcnQoW3tcclxuICAgICAgICAgICAgICB0aXRsZTogbWVzc2FnZURhdGEudGl0bGUsXHJcbiAgICAgICAgICAgICAgY29udGVudDogbWVzc2FnZURhdGEuY29udGVudCxcclxuICAgICAgICAgICAgICBzZW5kZXI6IG1lc3NhZ2VEYXRhLnNlbmRlcixcclxuICAgICAgICAgICAgICBzZW5kZXJfcm9sZTogbWVzc2FnZURhdGEuc2VuZGVyX3JvbGUsXHJcbiAgICAgICAgICAgICAgcmVjaXBpZW50czogbWVzc2FnZURhdGEucmVjaXBpZW50cyxcclxuICAgICAgICAgICAgICBjdXN0b21fZ3JvdXBzOiBtZXNzYWdlRGF0YS5jdXN0b21fZ3JvdXBzLFxyXG4gICAgICAgICAgICAgIHByaW9yaXR5OiBtZXNzYWdlRGF0YS5wcmlvcml0eSxcclxuICAgICAgICAgICAgICBhdHRhY2htZW50czogbWVzc2FnZURhdGEuYXR0YWNobWVudHMsXHJcbiAgICAgICAgICAgICAgc2NoZWR1bGVfdHlwZTogbWVzc2FnZURhdGEuc2NoZWR1bGVfdHlwZSxcclxuICAgICAgICAgICAgICBzY2hlZHVsZV9kYXRlOiBtZXNzYWdlRGF0YS5zY2hlZHVsZV9kYXRlLFxyXG4gICAgICAgICAgICAgIHNjaGVkdWxlX3RpbWU6IG1lc3NhZ2VEYXRhLnNjaGVkdWxlX3RpbWUsXHJcbiAgICAgICAgICAgICAgdG90YWxfcmVjaXBpZW50czogbWVzc2FnZURhdGEudG90YWxfcmVjaXBpZW50cyxcclxuICAgICAgICAgICAgICByZWFkX2NvdW50OiAwLFxyXG4gICAgICAgICAgICAgIGFja25vd2xlZGdlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgYWNrbm93bGVkZ2VkX2J5OiBbXSxcclxuICAgICAgICAgICAgfV0pXHJcbiAgICAgICAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAgICAgICAuc2luZ2xlKClcclxuXHJcbiAgICAgICAgICBpZiAocmV0cnlFcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyByZXRyeUVycm9yXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdXBhYmFzZU1lc3NhZ2UgPSByZXRyeURhdGFcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ01lc3NhZ2Ugc2F2ZWQgdG8gU3VwYWJhc2Ugc3VjY2Vzc2Z1bGx5IChsZWdhY3kgc2NoZW1hKTonLCByZXRyeURhdGEpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN1cGFiYXNlTWVzc2FnZSA9IGRhdGFcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdNZXNzYWdlIHNhdmVkIHRvIFN1cGFiYXNlIHN1Y2Nlc3NmdWxseTonLCBkYXRhKVxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoc3VwYWJhc2VFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignU3VwYWJhc2Ugb3BlcmF0aW9uIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIGxvY2FsIHN0b3JhZ2UnLCBzdXBhYmFzZUVycm9yKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDcmVhdGUgbWVzc2FnZSBvYmplY3QgKHVzZSBTdXBhYmFzZSBkYXRhIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGNyZWF0ZSBsb2NhbClcclxuICAgICAgY29uc3QgbmV3TWVzc2FnZTogTWVzc2FnZSA9IHN1cGFiYXNlTWVzc2FnZSB8fCB7XHJcbiAgICAgICAgaWQ6IE1hdGgubWF4KC4uLmdldCgpLm1lc3NhZ2VzLm1hcChtID0+IG0uaWQpLCAwKSArIDEsXHJcbiAgICAgICAgdGl0bGU6IG1lc3NhZ2VEYXRhLnRpdGxlLFxyXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2VEYXRhLmNvbnRlbnQsXHJcbiAgICAgICAgc2VuZGVyOiBtZXNzYWdlRGF0YS5zZW5kZXIsXHJcbiAgICAgICAgc2VuZGVyX3JvbGU6IG1lc3NhZ2VEYXRhLnNlbmRlcl9yb2xlLFxyXG4gICAgICAgIHJlY2lwaWVudHM6IG1lc3NhZ2VEYXRhLnJlY2lwaWVudHMsXHJcbiAgICAgICAgY3VzdG9tX2dyb3VwczogbWVzc2FnZURhdGEuY3VzdG9tX2dyb3VwcyxcclxuICAgICAgICBwcmlvcml0eTogbWVzc2FnZURhdGEucHJpb3JpdHksXHJcbiAgICAgICAgYXR0YWNobWVudHM6IG1lc3NhZ2VEYXRhLmF0dGFjaG1lbnRzLFxyXG4gICAgICAgIHNjaGVkdWxlX3R5cGU6IG1lc3NhZ2VEYXRhLnNjaGVkdWxlX3R5cGUsXHJcbiAgICAgICAgc2NoZWR1bGVfZGF0ZTogbWVzc2FnZURhdGEuc2NoZWR1bGVfZGF0ZSxcclxuICAgICAgICBzY2hlZHVsZV90aW1lOiBtZXNzYWdlRGF0YS5zY2hlZHVsZV90aW1lLFxyXG4gICAgICAgIHRvdGFsX3JlY2lwaWVudHM6IG1lc3NhZ2VEYXRhLnRvdGFsX3JlY2lwaWVudHMsXHJcbiAgICAgICAgcmVhZF9jb3VudDogMCxcclxuICAgICAgICByZWFkX2J5OiBbXSxcclxuICAgICAgICBhY2tub3dsZWRnZWQ6IGZhbHNlLFxyXG4gICAgICAgIGFja25vd2xlZGdlZF9ieTogW10sXHJcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2F2ZSB0byBsb2NhbCBzdGF0ZVxyXG4gICAgICBzZXQoKHN0YXRlKSA9PiAoeyBtZXNzYWdlczogW25ld01lc3NhZ2UsIC4uLnN0YXRlLm1lc3NhZ2VzXSB9KSlcclxuXHJcbiAgICAgIC8vIENyZWF0ZSBub3RpZmljYXRpb25zIGZvciByZWNpcGllbnRzXHJcbiAgICAgIGNvbnN0IHsgdXNlcnMsIGN1cnJlbnRVc2VyIH0gPSBnZXQoKVxyXG4gICAgICBsZXQgcmVjaXBpZW50VXNlcnM6IFVzZXJbXSA9IFtdXHJcblxyXG4gICAgICBpZiAobWVzc2FnZURhdGEucmVjaXBpZW50cyA9PT0gJ2FsbCcpIHtcclxuICAgICAgICByZWNpcGllbnRVc2VycyA9IHVzZXJzLmZpbHRlcih1ID0+IHUuaWQgIT09IGN1cnJlbnRVc2VyPy5pZClcclxuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlRGF0YS5yZWNpcGllbnRzID09PSAnc3R1ZGVudHMnKSB7XHJcbiAgICAgICAgcmVjaXBpZW50VXNlcnMgPSB1c2Vycy5maWx0ZXIodSA9PiB1LnJvbGUgPT09ICdzdHVkZW50JylcclxuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlRGF0YS5yZWNpcGllbnRzID09PSAnc3RhZmYnKSB7XHJcbiAgICAgICAgcmVjaXBpZW50VXNlcnMgPSB1c2Vycy5maWx0ZXIodSA9PiB1LnJvbGUgPT09ICdzdGFmZicpXHJcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZURhdGEucmVjaXBpZW50cyA9PT0gJ2FkbWlucycpIHtcclxuICAgICAgICByZWNpcGllbnRVc2VycyA9IHVzZXJzLmZpbHRlcih1ID0+IHUucm9sZSA9PT0gJ2FkbWluJylcclxuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlRGF0YS5yZWNpcGllbnRzID09PSAnZ3JvdXAnICYmIG1lc3NhZ2VEYXRhLmN1c3RvbV9ncm91cHMpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRFbWFpbHMgPSBuZXcgU2V0PHN0cmluZz4oKVxyXG4gICAgICAgIGNvbnN0IGFsbEdyb3VwcyA9IGdldCgpLmdyb3Vwc1xyXG5cclxuICAgICAgICBtZXNzYWdlRGF0YS5jdXN0b21fZ3JvdXBzLmZvckVhY2goZ3JvdXBJZCA9PiB7XHJcbiAgICAgICAgICBjb25zdCBncm91cCA9IGFsbEdyb3Vwcy5maW5kKGcgPT4gZy5pZCA9PT0gZ3JvdXBJZClcclxuICAgICAgICAgIGlmIChncm91cCAmJiBncm91cC5tZW1iZXJzKSB7XHJcbiAgICAgICAgICAgIGdyb3VwLm1lbWJlcnMuZm9yRWFjaChlbWFpbCA9PiB0YXJnZXRFbWFpbHMuYWRkKGVtYWlsKSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZWNpcGllbnRVc2VycyA9IHVzZXJzLmZpbHRlcih1ID0+IHRhcmdldEVtYWlscy5oYXModS5lbWFpbCkpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENyZWF0ZSBvbmUgbm90aWZpY2F0aW9uIHBlciByZWNpcGllbnQgKGF3YWl0IHRvIGF2b2lkIHJhY2VzKVxyXG4gICAgICBmb3IgKGNvbnN0IHVzZXIgb2YgcmVjaXBpZW50VXNlcnMpIHtcclxuICAgICAgICBhd2FpdCBnZXQoKS5hZGROb3RpZmljYXRpb24oe1xyXG4gICAgICAgICAgbWVzc2FnZV9pZDogbmV3TWVzc2FnZS5pZCxcclxuICAgICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXHJcbiAgICAgICAgICBtZXNzYWdlOiBgTmV3IG1lc3NhZ2U6ICR7bWVzc2FnZURhdGEudGl0bGV9YCxcclxuICAgICAgICAgIHJlYWQ6IGZhbHNlLFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBtZXNzYWdlOicsIGVycm9yKVxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH0sXHJcbiAgYWNrbm93bGVkZ2VNZXNzYWdlOiBhc3luYyAobWVzc2FnZUlkLCB1c2VySWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KClcclxuICAgICAgY29uc3QgY3VycmVudFVzZXIgPSBzdGF0ZS5jdXJyZW50VXNlclxyXG5cclxuICAgICAgaWYgKCFjdXJyZW50VXNlcikgcmV0dXJuXHJcblxyXG4gICAgICBjb25zdCBtZXNzYWdlID0gc3RhdGUubWVzc2FnZXMuZmluZChtID0+IG0uaWQgPT09IG1lc3NhZ2VJZClcclxuICAgICAgaWYgKCFtZXNzYWdlKSByZXR1cm5cclxuXHJcbiAgICAgIGNvbnN0IGN1cnJlbnRBY2tub3dsZWRnZWRCeSA9IG1lc3NhZ2UuYWNrbm93bGVkZ2VkX2J5IHx8IFtdXHJcbiAgICAgIGlmIChjdXJyZW50QWNrbm93bGVkZ2VkQnkuaW5jbHVkZXModXNlcklkKSkgcmV0dXJuXHJcblxyXG4gICAgICBjb25zdCBuZXdBY2tub3dsZWRnZWRCeSA9IFsuLi5jdXJyZW50QWNrbm93bGVkZ2VkQnksIHVzZXJJZF1cclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBsb2NhbCBzdGF0ZVxyXG4gICAgICBzZXQoKHN0YXRlKSA9PiAoe1xyXG4gICAgICAgIG1lc3NhZ2VzOiBzdGF0ZS5tZXNzYWdlcy5tYXAoKG1zZykgPT5cclxuICAgICAgICAgIG1zZy5pZCA9PT0gbWVzc2FnZUlkXHJcbiAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgIC4uLm1zZyxcclxuICAgICAgICAgICAgICBhY2tub3dsZWRnZWRfYnk6IG5ld0Fja25vd2xlZGdlZEJ5LFxyXG4gICAgICAgICAgICAgIGFja25vd2xlZGdlZDogdHJ1ZSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IG1zZ1xyXG4gICAgICAgICksXHJcbiAgICAgIH0pKVxyXG5cclxuICAgICAgLy8gVHJ5IHRvIHNhdmUgdG8gU3VwYWJhc2VcclxuICAgICAgaWYgKHN1cGFiYXNlKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIFVwZGF0ZSBtZXNzYWdlIGFja25vd2xlZGdlZCBzdGF0dXNcclxuICAgICAgICAgIGNvbnN0IHsgZGF0YTogdXBkYXRlRGF0YSwgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgICAuZnJvbSgnbWVzc2FnZXMnKVxyXG4gICAgICAgICAgICAudXBkYXRlKHtcclxuICAgICAgICAgICAgICBhY2tub3dsZWRnZWRfYnk6IG5ld0Fja25vd2xlZGdlZEJ5XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5lcSgnaWQnLCBtZXNzYWdlSWQpXHJcbiAgICAgICAgICAgIC5zZWxlY3QoKVxyXG5cclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdTdXBhYmFzZSB1cGRhdGUgcmVzdWx0OicsIHsgdXBkYXRlRGF0YSwgdXBkYXRlRXJyb3IgfSlcclxuXHJcbiAgICAgICAgICBpZiAodXBkYXRlRXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgbWVzc2FnZSBhY2tub3dsZWRnZW1lbnQ6JywgdXBkYXRlRXJyb3IpXHJcbiAgICAgICAgICAgIC8vIFRyeSBjYW1lbENhc2UganVzdCBpbiBjYXNlXHJcbiAgICAgICAgICAgIGNvbnN0IHsgZXJyb3I6IHJldHJ5RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgICAgICAgLmZyb20oJ21lc3NhZ2VzJylcclxuICAgICAgICAgICAgICAudXBkYXRlKHtcclxuICAgICAgICAgICAgICAgIGFja25vd2xlZGdlZEJ5OiBuZXdBY2tub3dsZWRnZWRCeVxyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgLmVxKCdpZCcsIG1lc3NhZ2VJZClcclxuICAgICAgICAgICAgICAuc2VsZWN0KClcclxuICAgICAgICAgICAgaWYgKCFyZXRyeUVycm9yKSBjb25zb2xlLmxvZygnUmV0cnkgd2l0aCBjYW1lbENhc2Ugc3VjY2VlZGVkJylcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBTdG9yZSBhY2tub3dsZWRnZW1lbnQgZGV0YWlscyAoaWdub3JlIGVycm9yIGlmIHRhYmxlIGRvZXNuJ3QgZXhpc3QpXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGFja0RhdGEsIGVycm9yOiBhY2tJbnNlcnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgICAuZnJvbSgnYWNrbm93bGVkZ2VtZW50cycpXHJcbiAgICAgICAgICAgICAgLmluc2VydCh7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlX2lkOiBtZXNzYWdlSWQsXHJcbiAgICAgICAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXHJcbiAgICAgICAgICAgICAgICB1c2VyX25hbWU6IGN1cnJlbnRVc2VyLm5hbWUsXHJcbiAgICAgICAgICAgICAgICB1c2VyX2VtYWlsOiBjdXJyZW50VXNlci5lbWFpbCxcclxuICAgICAgICAgICAgICAgIHVzZXJfcm9sZTogY3VycmVudFVzZXIucm9sZSxcclxuICAgICAgICAgICAgICAgIGFja25vd2xlZGdlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgLnNlbGVjdCgpXHJcblxyXG4gICAgICAgICAgICBpZiAoYWNrSW5zZXJ0RXJyb3IpIHtcclxuICAgICAgICAgICAgICAvLyBDb21tb24gY2F1c2VzOiB0YWJsZSBkb2Vzbid0IGV4aXN0LCBSTFMgb3IgcGVybWlzc2lvbiBpc3N1ZXMgKDQwMSksIG9yIHNjaGVtYSBtaXNtYXRjaFxyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGluc2VydCBpbnRvIGFja25vd2xlZGdlbWVudHMgdGFibGU6JywgYWNrSW5zZXJ0RXJyb3IpXHJcbiAgICAgICAgICAgICAgaWYgKGFja0luc2VydEVycm9yPy5jb2RlID09PSAnNDAxJyB8fCBTdHJpbmcoYWNrSW5zZXJ0RXJyb3I/Lm1lc3NhZ2UgfHwgJycpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3Blcm1pc3Npb24nKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbYWNrbm93bGVkZ2VtZW50c10gUGVybWlzc2lvbiBlcnJvciAoNDAxKS4gQ2hlY2sgU3VwYWJhc2UgUkxTIHBvbGljaWVzIGFuZCBhbm9uIGtleSBwZXJtaXNzaW9ucyBmb3IgaW5zZXJ0aW5nIGludG8gYGFja25vd2xlZGdlbWVudHNgLicpXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbYWNrbm93bGVkZ2VtZW50c10gSW5zZXJ0ZWQgYWNrbm93bGVkZ2VtZW50IHJvdzonLCBhY2tEYXRhKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChhY2tFcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuZXhwZWN0ZWQgZXJyb3IgaW5zZXJ0aW5nIGludG8gYWNrbm93bGVkZ2VtZW50cyB0YWJsZSAobWF5IG5vdCBleGlzdCBvciBpbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMpOicsIGFja0Vycm9yKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKHN1cGFiYXNlRXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIG9wZXJhdGlvbiBmYWlsZWQ6Jywgc3VwYWJhc2VFcnJvcilcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBhY2tub3dsZWRnZSBtZXNzYWdlOicsIGVycm9yKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGdldE1lc3NhZ2VBY2tub3dsZWRnZW1lbnREZXRhaWxzOiAobWVzc2FnZUlkKSA9PiB7XHJcbiAgICBjb25zdCBzdGF0ZSA9IGdldCgpXHJcbiAgICBjb25zdCBtZXNzYWdlID0gc3RhdGUubWVzc2FnZXMuZmluZChtID0+IG0uaWQgPT09IG1lc3NhZ2VJZClcclxuICAgIGlmICghbWVzc2FnZSkgcmV0dXJuIHsgYWNrbm93bGVkZ2VkOiBbXSwgcGVuZGluZzogW10gfVxyXG5cclxuICAgIGNvbnN0IGFja25vd2xlZGdlZFVzZXJJZHMgPSBtZXNzYWdlLmFja25vd2xlZGdlZF9ieSB8fCBbXVxyXG4gICAgY29uc3QgYWNrbm93bGVkZ2VkID0gc3RhdGUudXNlcnMuZmlsdGVyKHUgPT4gYWNrbm93bGVkZ2VkVXNlcklkcy5pbmNsdWRlcyh1LmlkKSlcclxuXHJcbiAgICAvLyBHZXQgcGVuZGluZyB1c2VycyBiYXNlZCBvbiBtZXNzYWdlIHJlY2lwaWVudHNcclxuICAgIGxldCBhbGxSZWNpcGllbnRzOiB0eXBlb2Ygc3RhdGUudXNlcnMgPSBbXVxyXG5cclxuICAgIGlmIChtZXNzYWdlLnJlY2lwaWVudHMgPT09ICdhbGwnKSB7XHJcbiAgICAgIGFsbFJlY2lwaWVudHMgPSBzdGF0ZS51c2Vycy5maWx0ZXIodSA9PiB1LmlkICE9PSBzdGF0ZS5jdXJyZW50VXNlcj8uaWQpXHJcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UucmVjaXBpZW50cyA9PT0gJ3N0dWRlbnRzJykge1xyXG4gICAgICBhbGxSZWNpcGllbnRzID0gc3RhdGUudXNlcnMuZmlsdGVyKHUgPT4gdS5yb2xlID09PSAnc3R1ZGVudCcpXHJcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UucmVjaXBpZW50cyA9PT0gJ3N0YWZmJykge1xyXG4gICAgICBhbGxSZWNpcGllbnRzID0gc3RhdGUudXNlcnMuZmlsdGVyKHUgPT4gdS5yb2xlID09PSAnc3RhZmYnKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBlbmRpbmcgPSBhbGxSZWNpcGllbnRzLmZpbHRlcih1ID0+ICFhY2tub3dsZWRnZWRVc2VySWRzLmluY2x1ZGVzKHUuaWQpKVxyXG5cclxuICAgIHJldHVybiB7IGFja25vd2xlZGdlZCwgcGVuZGluZyB9XHJcbiAgfSxcclxuXHJcbiAgbWFya01lc3NhZ2VBc1JlYWQ6IGFzeW5jIChtZXNzYWdlSWQpID0+IHtcclxuICAgIGNvbnN0IHN0YXRlID0gZ2V0KClcclxuICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gc3RhdGUuY3VycmVudFVzZXJcclxuICAgIGlmICghY3VycmVudFVzZXIpIHJldHVyblxyXG5cclxuICAgIGNvbnN0IG1lc3NhZ2UgPSBzdGF0ZS5tZXNzYWdlcy5maW5kKG0gPT4gbS5pZCA9PT0gbWVzc2FnZUlkKVxyXG4gICAgaWYgKCFtZXNzYWdlKSByZXR1cm5cclxuXHJcbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IHJlYWQgYnkgdGhpcyB1c2VyXHJcbiAgICBjb25zdCBjdXJyZW50UmVhZEJ5ID0gbWVzc2FnZS5yZWFkX2J5IHx8IFtdXHJcbiAgICBpZiAoY3VycmVudFJlYWRCeS5pbmNsdWRlcyhjdXJyZW50VXNlci5pZCkpIHJldHVyblxyXG5cclxuICAgIGNvbnN0IG5ld1JlYWRCeSA9IFsuLi5jdXJyZW50UmVhZEJ5LCBjdXJyZW50VXNlci5pZF1cclxuICAgIGNvbnN0IG5ld1JlYWRDb3VudCA9IChtZXNzYWdlLnJlYWRfY291bnQgfHwgMCkgKyAxXHJcblxyXG4gICAgLy8gVXBkYXRlIGxvY2FsIHN0YXRlXHJcbiAgICBzZXQoKHN0YXRlKSA9PiAoe1xyXG4gICAgICBtZXNzYWdlczogc3RhdGUubWVzc2FnZXMubWFwKChtc2cpID0+XHJcbiAgICAgICAgbXNnLmlkID09PSBtZXNzYWdlSWRcclxuICAgICAgICAgID8geyAuLi5tc2csIHJlYWRfY291bnQ6IG5ld1JlYWRDb3VudCwgcmVhZF9ieTogbmV3UmVhZEJ5IH1cclxuICAgICAgICAgIDogbXNnXHJcbiAgICAgICksXHJcbiAgICB9KSlcclxuXHJcbiAgICAvLyBVcGRhdGUgU3VwYWJhc2VcclxuICAgIGlmIChzdXBhYmFzZSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgICAuZnJvbSgnbWVzc2FnZXMnKVxyXG4gICAgICAgICAgLnVwZGF0ZSh7XHJcbiAgICAgICAgICAgIHJlYWRfY291bnQ6IG5ld1JlYWRDb3VudCxcclxuICAgICAgICAgICAgcmVhZF9ieTogbmV3UmVhZEJ5XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLmVxKCdpZCcsIG1lc3NhZ2VJZClcclxuXHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB1cGRhdGUgcmVhZF9ieSwgZmFsbGluZyBiYWNrIHRvIHNpbXBsZSByZWFkX2NvdW50IGluY3JlbWVudCcsIGVycm9yKVxyXG4gICAgICAgICAgLy8gRmFsbGJhY2s6IGp1c3QgdXBkYXRlIHJlYWRfY291bnRcclxuICAgICAgICAgIGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgICAgIC5mcm9tKCdtZXNzYWdlcycpXHJcbiAgICAgICAgICAgIC51cGRhdGUoe1xyXG4gICAgICAgICAgICAgIHJlYWRfY291bnQ6IG5ld1JlYWRDb3VudFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZXEoJ2lkJywgbWVzc2FnZUlkKVxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBtZXNzYWdlIHJlYWQgc3RhdHVzOicsIGVycm9yKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZmV0Y2hNZXNzYWdlczogYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVHJ5IG5vcm1hbCBmZXRjaCBmaXJzdFxyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdtZXNzYWdlcycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAvLyBJZiBQb3N0Z1JFU1QgcmV0dXJucyBhbiBlcnJvciBkdWUgdG8gbWlzc2luZyBjb2x1bW5zIGluIHNjaGVtYSAoNDAwKSxcclxuICAgICAgICAvLyByZXRyeSB3aXRoIGEgc2FmZSByZWR1Y2VkIGNvbHVtbiBsaXN0IHRoYXQgc2hvdWxkIGV4aXN0IG9uIG1vc3Qgc2NoZW1hcy5cclxuICAgICAgICBjb25zb2xlLndhcm4oJ1tmZXRjaE1lc3NhZ2VzXSBJbml0aWFsIGZldGNoIGZhaWxlZCwgcmV0cnlpbmcgd2l0aCBzYWZlIGNvbHVtbiBzZXQ6JywgZXJyb3IpXHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBzYWZlQ29sdW1ucyA9IFtcclxuICAgICAgICAgICAgJ2lkJywgJ3RpdGxlJywgJ2NvbnRlbnQnLCAnc2VuZGVyJywgJ3NlbmRlcl9yb2xlJywgJ3JlY2lwaWVudHMnLFxyXG4gICAgICAgICAgICAnY3VzdG9tX2dyb3VwcycsICdwcmlvcml0eScsICdhdHRhY2htZW50cycsICdzY2hlZHVsZV90eXBlJyxcclxuICAgICAgICAgICAgJ3NjaGVkdWxlX2RhdGUnLCAnc2NoZWR1bGVfdGltZScsICd0b3RhbF9yZWNpcGllbnRzJywgJ3JlYWRfY291bnQnLFxyXG4gICAgICAgICAgICAnYWNrbm93bGVkZ2VkJywgJ2NyZWF0ZWRfYXQnLCAndXBkYXRlZF9hdCdcclxuICAgICAgICAgIF0uam9pbignLCcpXHJcblxyXG4gICAgICAgICAgY29uc3QgeyBkYXRhOiBzYWZlRGF0YSwgZXJyb3I6IHNhZmVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgICAgLmZyb20oJ21lc3NhZ2VzJylcclxuICAgICAgICAgICAgLnNlbGVjdChzYWZlQ29sdW1ucylcclxuICAgICAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcblxyXG4gICAgICAgICAgaWYgKHNhZmVFcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbZmV0Y2hNZXNzYWdlc10gU2FmZSByZXRyeSBhbHNvIGZhaWxlZDonLCBzYWZlRXJyb3IpXHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChzYWZlRGF0YSAmJiBBcnJheS5pc0FycmF5KHNhZmVEYXRhKSAmJiBzYWZlRGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIFR5cGUgZ3VhcmQ6IHZlcmlmeSBmaXJzdCBpdGVtIGhhcyBleHBlY3RlZCBNZXNzYWdlIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgY29uc3QgZmlyc3RJdGVtID0gc2FmZURhdGFbMF1cclxuICAgICAgICAgICAgaWYgKGZpcnN0SXRlbSAmJiB0eXBlb2YgZmlyc3RJdGVtID09PSAnb2JqZWN0JyAmJiAnaWQnIGluIGZpcnN0SXRlbSAmJiAndGl0bGUnIGluIGZpcnN0SXRlbSkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbZmV0Y2hNZXNzYWdlc10gRmV0Y2hlZCBtZXNzYWdlcyAoc2FmZSBjb2x1bW5zKSBzYW1wbGU6JywgZmlyc3RJdGVtKVxyXG4gICAgICAgICAgICAgIHNldCgoKSA9PiAoeyBtZXNzYWdlczogc2FmZURhdGEgYXMgdW5rbm93biBhcyBNZXNzYWdlW10gfSkpXHJcbiAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKHNhZmVEYXRhICYmIEFycmF5LmlzQXJyYXkoc2FmZURhdGEpICYmIHNhZmVEYXRhLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW2ZldGNoTWVzc2FnZXNdIE5vIG1lc3NhZ2VzIGZvdW5kJylcclxuICAgICAgICAgICAgc2V0KCgpID0+ICh7IG1lc3NhZ2VzOiBbXSB9KSlcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAocmV0cnlFcnIpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tmZXRjaE1lc3NhZ2VzXSBSZXRyeSB3aXRoIHNhZmUgY29sdW1ucyBmYWlsZWQ6JywgcmV0cnlFcnIpXHJcbiAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChkYXRhICYmIEFycmF5LmlzQXJyYXkoZGF0YSkgJiYgZGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gVHlwZSBndWFyZDogdmVyaWZ5IGZpcnN0IGl0ZW0gaGFzIGV4cGVjdGVkIE1lc3NhZ2UgcHJvcGVydGllc1xyXG4gICAgICAgIGNvbnN0IGZpcnN0SXRlbSA9IGRhdGFbMF1cclxuICAgICAgICBpZiAoZmlyc3RJdGVtICYmIHR5cGVvZiBmaXJzdEl0ZW0gPT09ICdvYmplY3QnICYmICdpZCcgaW4gZmlyc3RJdGVtICYmICd0aXRsZScgaW4gZmlyc3RJdGVtKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnRmV0Y2hlZCBtZXNzYWdlcyBzYW1wbGU6JywgZmlyc3RJdGVtKVxyXG4gICAgICAgICAgc2V0KCgpID0+ICh7IG1lc3NhZ2VzOiBkYXRhIGFzIHVua25vd24gYXMgTWVzc2FnZVtdIH0pKVxyXG4gICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZGF0YSAmJiBBcnJheS5pc0FycmF5KGRhdGEpICYmIGRhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1tmZXRjaE1lc3NhZ2VzXSBObyBtZXNzYWdlcyBmb3VuZCAoaW5pdGlhbCBmZXRjaCknKVxyXG4gICAgICAgIHNldCgoKSA9PiAoeyBtZXNzYWdlczogW10gfSkpXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG1lc3NhZ2VzOicsIGVycm9yKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIEdyb3VwIEFjdGlvbnNcclxuICBhZGRHcm91cDogYXN5bmMgKGdyb3VwRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnZ3JvdXBzJylcclxuICAgICAgICAuaW5zZXJ0KFtncm91cERhdGFdKVxyXG4gICAgICAgIC5zZWxlY3QoKVxyXG5cclxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG5cclxuICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xyXG4gICAgICAgICAgZ3JvdXBzOiBbLi4uc3RhdGUuZ3JvdXBzLCAuLi5kYXRhXSxcclxuICAgICAgICB9KSlcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIGdyb3VwOicsIGVycm9yKVxyXG4gICAgICBjb25zdCBuZXdHcm91cDogR3JvdXAgPSB7XHJcbiAgICAgICAgLi4uZ3JvdXBEYXRhLFxyXG4gICAgICAgIGlkOiBNYXRoLm1heCguLi5nZXQoKS5ncm91cHMubWFwKGcgPT4gZy5pZCksIDApICsgMSxcclxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB9XHJcbiAgICAgIHNldCgoc3RhdGUpID0+ICh7IGdyb3VwczogWy4uLnN0YXRlLmdyb3VwcywgbmV3R3JvdXBdIH0pKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZUdyb3VwOiBhc3luYyAoaWQsIGdyb3VwRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnZ3JvdXBzJylcclxuICAgICAgICAudXBkYXRlKHsgLi4uZ3JvdXBEYXRhLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSlcclxuICAgICAgICAuZXEoJ2lkJywgaWQpXHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcblxyXG4gICAgICBzZXQoKHN0YXRlKSA9PiAoe1xyXG4gICAgICAgIGdyb3Vwczogc3RhdGUuZ3JvdXBzLm1hcCgoZ3JvdXApID0+XHJcbiAgICAgICAgICBncm91cC5pZCA9PT0gaWRcclxuICAgICAgICAgICAgPyB7IC4uLmdyb3VwLCAuLi5ncm91cERhdGEsIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9XHJcbiAgICAgICAgICAgIDogZ3JvdXBcclxuICAgICAgICApLFxyXG4gICAgICB9KSlcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGdyb3VwOicsIGVycm9yKVxyXG4gICAgICBzZXQoKHN0YXRlKSA9PiAoe1xyXG4gICAgICAgIGdyb3Vwczogc3RhdGUuZ3JvdXBzLm1hcCgoZ3JvdXApID0+XHJcbiAgICAgICAgICBncm91cC5pZCA9PT0gaWRcclxuICAgICAgICAgICAgPyB7IC4uLmdyb3VwLCAuLi5ncm91cERhdGEsIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9XHJcbiAgICAgICAgICAgIDogZ3JvdXBcclxuICAgICAgICApLFxyXG4gICAgICB9KSlcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBkZWxldGVHcm91cDogYXN5bmMgKGlkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdncm91cHMnKVxyXG4gICAgICAgIC5kZWxldGUoKVxyXG4gICAgICAgIC5lcSgnaWQnLCBpZClcclxuXHJcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuXHJcbiAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgZ3JvdXBzOiBzdGF0ZS5ncm91cHMuZmlsdGVyKChncm91cCkgPT4gZ3JvdXAuaWQgIT09IGlkKSxcclxuICAgICAgfSkpXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBncm91cDonLCBlcnJvcilcclxuICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgICBncm91cHM6IHN0YXRlLmdyb3Vwcy5maWx0ZXIoKGdyb3VwKSA9PiBncm91cC5pZCAhPT0gaWQpLFxyXG4gICAgICB9KSlcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBmZXRjaEdyb3VwczogYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnZ3JvdXBzJylcclxuICAgICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuXHJcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuXHJcbiAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgc2V0KCgpID0+ICh7IGdyb3VwczogZGF0YSB9KSlcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZ3JvdXBzOicsIGVycm9yKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIERlcGFydG1lbnQgQWN0aW9uc1xyXG4gIGFkZERlcGFydG1lbnQ6IGFzeW5jIChkZXBhcnRtZW50RGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnZGVwYXJ0bWVudHMnKVxyXG4gICAgICAgIC5pbnNlcnQoW2RlcGFydG1lbnREYXRhXSlcclxuICAgICAgICAuc2VsZWN0KClcclxuXHJcbiAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N1cGFiYXNlIGVycm9yIGFkZGluZyBkZXBhcnRtZW50OicsIGVycm9yKVxyXG4gICAgICAgIHRocm93IGVycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgICAgIGRlcGFydG1lbnRzOiBbLi4uc3RhdGUuZGVwYXJ0bWVudHMsIC4uLmRhdGFdLFxyXG4gICAgICAgIH0pKVxyXG4gICAgICAgIHJldHVybiBkYXRhWzBdIGFzIERlcGFydG1lbnRcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIGRlcGFydG1lbnQ6JywgZXJyb3IpXHJcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGxvY2FsIHN0YXRlIGlmIFN1cGFiYXNlIGZhaWxzXHJcbiAgICAgIGNvbnN0IG5ld0RlcGFydG1lbnQ6IERlcGFydG1lbnQgPSB7XHJcbiAgICAgICAgLi4uZGVwYXJ0bWVudERhdGEsXHJcbiAgICAgICAgaWQ6IE1hdGgubWF4KC4uLmdldCgpLmRlcGFydG1lbnRzLm1hcChkID0+IGQuaWQpLCAwKSArIDEsXHJcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgfVxyXG4gICAgICBzZXQoKHN0YXRlKSA9PiAoeyBkZXBhcnRtZW50czogWy4uLnN0YXRlLmRlcGFydG1lbnRzLCBuZXdEZXBhcnRtZW50XSB9KSlcclxuICAgICAgcmV0dXJuIG5ld0RlcGFydG1lbnRcclxuICAgIH1cclxuICB9LFxyXG5cclxuICB1cGRhdGVEZXBhcnRtZW50OiBhc3luYyAoaWQsIGRlcGFydG1lbnREYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBHZXQgdGhlIG9sZCBkZXBhcnRtZW50IG5hbWUgYmVmb3JlIHVwZGF0aW5nXHJcbiAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KClcclxuICAgICAgY29uc3Qgb2xkRGVwYXJ0bWVudCA9IHN0YXRlLmRlcGFydG1lbnRzLmZpbmQoZCA9PiBkLmlkID09PSBpZClcclxuICAgICAgY29uc3Qgb2xkRGVwdE5hbWUgPSBvbGREZXBhcnRtZW50Py5uYW1lXHJcbiAgICAgIGNvbnN0IG5ld0RlcHROYW1lID0gZGVwYXJ0bWVudERhdGEubmFtZVxyXG5cclxuICAgICAgY29uc29sZS5sb2coYFVwZGF0aW5nIGRlcGFydG1lbnQ6IFwiJHtvbGREZXB0TmFtZX1cIiDihpIgXCIke25ld0RlcHROYW1lfVwiYClcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgZGVwYXJ0bWVudCBpbiBTdXBhYmFzZVxyXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdkZXBhcnRtZW50cycpXHJcbiAgICAgICAgLnVwZGF0ZSh7IC4uLmRlcGFydG1lbnREYXRhLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSlcclxuICAgICAgICAuZXEoJ2lkJywgaWQpXHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIHVwZGF0aW5nIGRlcGFydG1lbnQgaW4gU3VwYWJhc2U6JywgZXJyb3IpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIGRlcGFydG1lbnQgbmFtZSBjaGFuZ2VkLCB1cGRhdGUgYWxsIHVzZXJzIHdpdGggdGhlIG9sZCBkZXBhcnRtZW50IG5hbWVcclxuICAgICAgaWYgKG9sZERlcHROYW1lICYmIG5ld0RlcHROYW1lICYmIG9sZERlcHROYW1lICE9PSBuZXdEZXB0TmFtZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBVcGRhdGluZyB1c2VycyB3aXRoIGRlcGFydG1lbnQ6IFwiJHtvbGREZXB0TmFtZX1cImApXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVXBkYXRlIGluIFN1cGFiYXNlXHJcbiAgICAgICAgY29uc3QgeyBlcnJvcjogdXNlcnNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgIC5mcm9tKCd1c2VycycpXHJcbiAgICAgICAgICAudXBkYXRlKHsgZGVwYXJ0bWVudDogbmV3RGVwdE5hbWUsIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KVxyXG4gICAgICAgICAgLmVxKCdkZXBhcnRtZW50Jywgb2xkRGVwdE5hbWUpXHJcblxyXG4gICAgICAgIGlmICh1c2Vyc0Vycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIHVwZGF0aW5nIHVzZXJzIHdpdGggbmV3IGRlcGFydG1lbnQgbmFtZTonLCB1c2Vyc0Vycm9yKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgdXNlcnMgaW4gU3VwYWJhc2VgKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXBkYXRlIGxvY2FsIHN0YXRlXHJcbiAgICAgIHNldCgoc3RhdGUpID0+IHtcclxuICAgICAgICBjb25zdCB1cGRhdGVkVXNlcnMgPSBzdGF0ZS51c2Vycy5tYXAoKHVzZXIpID0+IHtcclxuICAgICAgICAgIGlmICh1c2VyLmRlcGFydG1lbnQgPT09IG9sZERlcHROYW1lICYmIG5ld0RlcHROYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBVcGRhdGluZyB1c2VyICR7dXNlci5uYW1lfTogXCIke3VzZXIuZGVwYXJ0bWVudH1cIiDihpIgXCIke25ld0RlcHROYW1lfVwiYClcclxuICAgICAgICAgICAgcmV0dXJuIHsgLi4udXNlciwgZGVwYXJ0bWVudDogbmV3RGVwdE5hbWUsIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gdXNlclxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBkZXBhcnRtZW50czogc3RhdGUuZGVwYXJ0bWVudHMubWFwKChkZXBhcnRtZW50KSA9PlxyXG4gICAgICAgICAgICBkZXBhcnRtZW50LmlkID09PSBpZFxyXG4gICAgICAgICAgICAgID8geyAuLi5kZXBhcnRtZW50LCAuLi5kZXBhcnRtZW50RGF0YSwgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH1cclxuICAgICAgICAgICAgICA6IGRlcGFydG1lbnRcclxuICAgICAgICAgICksXHJcbiAgICAgICAgICB1c2VyczogdXBkYXRlZFVzZXJzLFxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGRlcGFydG1lbnQ6JywgZXJyb3IpXHJcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGxvY2FsIHN0YXRlIHVwZGF0ZVxyXG4gICAgICBzZXQoKHN0YXRlKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb2xkRGVwdE5hbWUgPSBzdGF0ZS5kZXBhcnRtZW50cy5maW5kKGQgPT4gZC5pZCA9PT0gaWQpPy5uYW1lXHJcbiAgICAgICAgY29uc3QgbmV3RGVwdE5hbWUgPSBkZXBhcnRtZW50RGF0YS5uYW1lXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGRlcGFydG1lbnRzOiBzdGF0ZS5kZXBhcnRtZW50cy5tYXAoKGRlcGFydG1lbnQpID0+XHJcbiAgICAgICAgICAgIGRlcGFydG1lbnQuaWQgPT09IGlkXHJcbiAgICAgICAgICAgICAgPyB7IC4uLmRlcGFydG1lbnQsIC4uLmRlcGFydG1lbnREYXRhLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfVxyXG4gICAgICAgICAgICAgIDogZGVwYXJ0bWVudFxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIHVzZXJzOiBzdGF0ZS51c2Vycy5tYXAoKHVzZXIpID0+XHJcbiAgICAgICAgICAgIHVzZXIuZGVwYXJ0bWVudCA9PT0gb2xkRGVwdE5hbWUgJiYgbmV3RGVwdE5hbWVcclxuICAgICAgICAgICAgICA/IHsgLi4udXNlciwgZGVwYXJ0bWVudDogbmV3RGVwdE5hbWUgfVxyXG4gICAgICAgICAgICAgIDogdXNlclxyXG4gICAgICAgICAgKSxcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZGVsZXRlRGVwYXJ0bWVudDogYXN5bmMgKGlkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdkZXBhcnRtZW50cycpXHJcbiAgICAgICAgLmRlbGV0ZSgpXHJcbiAgICAgICAgLmVxKCdpZCcsIGlkKVxyXG5cclxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxyXG5cclxuICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgICBkZXBhcnRtZW50czogc3RhdGUuZGVwYXJ0bWVudHMuZmlsdGVyKChkZXBhcnRtZW50KSA9PiBkZXBhcnRtZW50LmlkICE9PSBpZCksXHJcbiAgICAgIH0pKVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgZGVwYXJ0bWVudDonLCBlcnJvcilcclxuICAgICAgLy8gRmFsbGJhY2sgdG8gbG9jYWwgc3RhdGVcclxuICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgICBkZXBhcnRtZW50czogc3RhdGUuZGVwYXJ0bWVudHMuZmlsdGVyKChkZXBhcnRtZW50KSA9PiBkZXBhcnRtZW50LmlkICE9PSBpZCksXHJcbiAgICAgIH0pKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGZldGNoRGVwYXJ0bWVudHM6IGFzeW5jICgpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2RlcGFydG1lbnRzJylcclxuICAgICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuXHJcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuXHJcbiAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgc2V0KCgpID0+ICh7IGRlcGFydG1lbnRzOiBkYXRhIH0pKVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBkZXBhcnRtZW50czonLCBlcnJvcilcclxuICAgICAgLy8gS2VlcCBleGlzdGluZyBsb2NhbCBkZXBhcnRtZW50cyBpZiBmZXRjaCBmYWlsc1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIE5vdGlmaWNhdGlvbiBBY3Rpb25zXHJcbiAgYWRkTm90aWZpY2F0aW9uOiBhc3luYyAobm90aWZpY2F0aW9uRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gRGVkdXA6IGNoZWNrIGxvY2FsIHN0YXRlIGZpcnN0XHJcbiAgICAgIGNvbnN0IGV4aXN0c0xvY2FsbHkgPSBnZXQoKS5ub3RpZmljYXRpb25zLnNvbWUoXHJcbiAgICAgICAgKG4pID0+IG4ubWVzc2FnZV9pZCA9PT0gbm90aWZpY2F0aW9uRGF0YS5tZXNzYWdlX2lkICYmIG4udXNlcl9pZCA9PT0gbm90aWZpY2F0aW9uRGF0YS51c2VyX2lkXHJcbiAgICAgIClcclxuXHJcbiAgICAgIGlmIChleGlzdHNMb2NhbGx5KSB7XHJcbiAgICAgICAgY29uc29sZS5pbmZvKCdOb3RpZmljYXRpb24gZGVkdXA6IGZvdW5kIGxvY2FsbHksIHNraXBwaW5nJywgbm90aWZpY2F0aW9uRGF0YSlcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgU3VwYWJhc2UgZm9yIGV4aXN0aW5nIG5vdGlmaWNhdGlvbiBmb3Igc2FtZSBtZXNzYWdlICsgdXNlclxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YTogZXhpc3RpbmcsIGVycm9yOiBzZWxlY3RFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAgIC5mcm9tKCdub3RpZmljYXRpb25zJylcclxuICAgICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgICAgLmVxKCdtZXNzYWdlX2lkJywgbm90aWZpY2F0aW9uRGF0YS5tZXNzYWdlX2lkKVxyXG4gICAgICAgICAgLmVxKCd1c2VyX2lkJywgbm90aWZpY2F0aW9uRGF0YS51c2VyX2lkKVxyXG4gICAgICAgICAgLmxpbWl0KDEpXHJcblxyXG4gICAgICAgIGlmIChzZWxlY3RFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdTdXBhYmFzZSBzZWxlY3QgZXJyb3Igd2hpbGUgY2hlY2tpbmcgbm90aWZpY2F0aW9ucyBkZWR1cDonLCBzZWxlY3RFcnJvci5tZXNzYWdlIHx8IHNlbGVjdEVycm9yKVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZXhpc3RpbmcgJiYgZXhpc3RpbmcubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc29sZS5pbmZvKCdOb3RpZmljYXRpb24gZGVkdXA6IGZvdW5kIGluIFN1cGFiYXNlLCBza2lwcGluZycsIG5vdGlmaWNhdGlvbkRhdGEpXHJcbiAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignU3VwYWJhc2Ugbm90IGF2YWlsYWJsZSB3aGVuIGNoZWNraW5nIG5vdGlmaWNhdGlvbiBkZWR1cCwgY29udGludWluZyB3aXRoIGxvY2FsIG9ubHkgY2hlY2snKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUcnkgdG8gcGVyc2lzdCB0byBTdXBhYmFzZVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgICAuZnJvbSgnbm90aWZpY2F0aW9ucycpXHJcbiAgICAgICAgICAuaW5zZXJ0KFtub3RpZmljYXRpb25EYXRhXSlcclxuICAgICAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAgICAgLnNpbmdsZSgpXHJcblxyXG4gICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdTdXBhYmFzZSBpbnNlcnQgZXJyb3IgZm9yIG5vdGlmaWNhdGlvbiwgZmFsbGluZyBiYWNrIHRvIGxvY2FsOicsIGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgLy8gVXNlIHJldHVybmVkIFN1cGFiYXNlIHJvdyB0byBtYWludGFpbiBjb25zaXN0ZW50IGlkcy9jcmVhdGVkX2F0XHJcbiAgICAgICAgICBzZXQoKHN0YXRlKSA9PiAoeyBub3RpZmljYXRpb25zOiBbZGF0YSBhcyBOb3RpZmljYXRpb24sIC4uLnN0YXRlLm5vdGlmaWNhdGlvbnNdIH0pKVxyXG4gICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChzdXBhYmFzZUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdTdXBhYmFzZSB1bmF2YWlsYWJsZSB3aGVuIGluc2VydGluZyBub3RpZmljYXRpb24sIHdpbGwgYWRkIGxvY2FsbHknKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGYWxsYmFjay9sb2NhbCBpbnNlcnRpb25cclxuICAgICAgY29uc3QgbmV3Tm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb24gPSB7XHJcbiAgICAgICAgLi4ubm90aWZpY2F0aW9uRGF0YSxcclxuICAgICAgICBpZDogTWF0aC5tYXgoLi4uZ2V0KCkubm90aWZpY2F0aW9ucy5tYXAobiA9PiBuLmlkKSwgMCkgKyAxLFxyXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgfVxyXG5cclxuICAgICAgc2V0KChzdGF0ZSkgPT4gKHsgbm90aWZpY2F0aW9uczogW25ld05vdGlmaWNhdGlvbiwgLi4uc3RhdGUubm90aWZpY2F0aW9uc10gfSkpXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gYWRkIG5vdGlmaWNhdGlvbjonLCBlcnJvcilcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBtYXJrTm90aWZpY2F0aW9uQXNSZWFkOiAoaWQpID0+IHtcclxuICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgIG5vdGlmaWNhdGlvbnM6IHN0YXRlLm5vdGlmaWNhdGlvbnMubWFwKChub3RpZikgPT5cclxuICAgICAgICBub3RpZi5pZCA9PT0gaWQgPyB7IC4uLm5vdGlmLCByZWFkOiB0cnVlIH0gOiBub3RpZlxyXG4gICAgICApLFxyXG4gICAgfSkpXHJcbiAgfSxcclxuXHJcbiAgbWFya05vdGlmaWNhdGlvbnNBc1JlYWRGb3JNZXNzYWdlOiAobWVzc2FnZUlkKSA9PiB7XHJcbiAgICBzZXQoKHN0YXRlKSA9PiAoe1xyXG4gICAgICBub3RpZmljYXRpb25zOiBzdGF0ZS5ub3RpZmljYXRpb25zLm1hcCgobm90aWYpID0+XHJcbiAgICAgICAgbm90aWYubWVzc2FnZV9pZCA9PT0gbWVzc2FnZUlkID8geyAuLi5ub3RpZiwgcmVhZDogdHJ1ZSB9IDogbm90aWZcclxuICAgICAgKSxcclxuICAgIH0pKVxyXG4gIH0sXHJcblxyXG4gIGdldFVucmVhZE5vdGlmaWNhdGlvbnM6ICgpID0+IHtcclxuICAgIGNvbnN0IHsgbm90aWZpY2F0aW9ucywgY3VycmVudFVzZXIgfSA9IGdldCgpXHJcbiAgICByZXR1cm4gbm90aWZpY2F0aW9ucy5maWx0ZXIoXHJcbiAgICAgIChuKSA9PiBuLnVzZXJfaWQgPT09IGN1cnJlbnRVc2VyPy5pZCAmJiAhbi5yZWFkXHJcbiAgICApXHJcbiAgfSxcclxuXHJcbiAgLy8gQ29tbWVudCBBY3Rpb25zXHJcbiAgZmV0Y2hDb21tZW50czogYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY29tbWVudHMnKVxyXG4gICAgICAgIC5zZWxlY3QoJyonKVxyXG4gICAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGZldGNoaW5nIGNvbW1lbnRzIGZyb20gU3VwYWJhc2U6JywgZXJyb3IpXHJcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSkge1xyXG4gICAgICAgIHNldCgoKSA9PiAoeyBjb21tZW50czogZGF0YSBhcyBDb21tZW50W10gfSkpXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNvbW1lbnRzOicsIGVycm9yKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGFkZENvbW1lbnQ6IGFzeW5jIChjb21tZW50RGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVHJ5IFN1cGFiYXNlIGluc2VydCBmaXJzdFxyXG4gICAgICBsZXQgc2F2ZWRDb21tZW50OiBDb21tZW50IHwgbnVsbCA9IG51bGxcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgLmZyb20oJ2NvbW1lbnRzJylcclxuICAgICAgICAgIC5pbnNlcnQoW2NvbW1lbnREYXRhXSlcclxuICAgICAgICAgIC5zZWxlY3QoKVxyXG4gICAgICAgICAgLnNpbmdsZSgpXHJcblxyXG4gICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdTdXBhYmFzZSBpbnNlcnQgY29tbWVudCBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBsb2NhbCcsIGVycm9yKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzYXZlZENvbW1lbnQgPSBkYXRhIGFzIENvbW1lbnRcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKHN1cGFiYXNlRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ1N1cGFiYXNlIHVuYXZhaWxhYmxlIGZvciBjb21tZW50cywgd2lsbCB1c2UgbG9jYWwgc3RhdGUnLCBzdXBhYmFzZUVycm9yKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBuZXdDb21tZW50OiBDb21tZW50ID0gc2F2ZWRDb21tZW50IHx8IHtcclxuICAgICAgICBpZDogTWF0aC5tYXgoLi4uZ2V0KCkuY29tbWVudHMubWFwKGMgPT4gYy5pZCksIDApICsgMSxcclxuICAgICAgICAuLi5jb21tZW50RGF0YSxcclxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBZGQgdG8gbG9jYWwgc3RhdGVcclxuICAgICAgc2V0KChzdGF0ZSkgPT4gKHsgY29tbWVudHM6IFsuLi5zdGF0ZS5jb21tZW50cywgbmV3Q29tbWVudF0gfSkpXHJcblxyXG4gICAgICAvLyBOb3RpZnkgbWVzc2FnZSBzZW5kZXIgKGlmIG5vdCB0aGUgY29tbWVudGVyKVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZXQoKS5tZXNzYWdlcy5maW5kKG0gPT4gbS5pZCA9PT0gbmV3Q29tbWVudC5tZXNzYWdlX2lkKVxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gZ2V0KCkuY3VycmVudFVzZXJcclxuICAgICAgICBpZiAobWVzc2FnZSAmJiBjdXJyZW50VXNlciAmJiBtZXNzYWdlLnNlbmRlciAhPT0gY3VycmVudFVzZXIuZW1haWwpIHtcclxuICAgICAgICAgIGF3YWl0IGdldCgpLmFkZE5vdGlmaWNhdGlvbih7XHJcbiAgICAgICAgICAgIG1lc3NhZ2VfaWQ6IG1lc3NhZ2UuaWQsXHJcbiAgICAgICAgICAgIHVzZXJfaWQ6IG1lc3NhZ2Uuc2VuZGVyICYmIGdldCgpLnVzZXJzLmZpbmQodSA9PiB1LmVtYWlsID09PSBtZXNzYWdlLnNlbmRlcik/LmlkID8gZ2V0KCkudXNlcnMuZmluZCh1ID0+IHUuZW1haWwgPT09IG1lc3NhZ2Uuc2VuZGVyKSEuaWQgOiAwLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBgTmV3IGNvbW1lbnQgb246ICR7bWVzc2FnZS50aXRsZX1gLFxyXG4gICAgICAgICAgICByZWFkOiBmYWxzZSxcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChub3RpZnlFcnIpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjcmVhdGUgbm90aWZpY2F0aW9uIGZvciBjb21tZW50OicsIG5vdGlmeUVycilcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSGFuZGxlIHJvbGUgbWVudGlvbnMgbGlrZSBAc3RhZmYgb3IgQHN0dWRlbnRzXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgbWVudGlvbnMgPSAobmV3Q29tbWVudC5jb250ZW50IHx8ICcnKS5tYXRjaCgvQChzdGFmZnxzdHVkZW50c3xhZG1pbnMpXFxiL2cpXHJcbiAgICAgICAgaWYgKG1lbnRpb25zICYmIG1lbnRpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnN0IHJvbGVzID0gQXJyYXkuZnJvbShuZXcgU2V0KG1lbnRpb25zLm1hcChtID0+IG0ucmVwbGFjZSgnQCcsICcnKSkpKVxyXG4gICAgICAgICAgY29uc3QgdXNlcnNUb05vdGlmeTogVXNlcltdID0gW11cclxuICAgICAgICAgIGZvciAoY29uc3Qgcm9sZSBvZiByb2xlcykge1xyXG4gICAgICAgICAgICBpZiAocm9sZSA9PT0gJ3N0YWZmJyB8fCByb2xlID09PSAnc3R1ZGVudHMnIHx8IHJvbGUgPT09ICdhZG1pbnMnKSB7XHJcbiAgICAgICAgICAgICAgY29uc3Qgcm9sZUtleSA9IHJvbGUgPT09ICdzdHVkZW50cycgPyAnc3R1ZGVudCcgOiByb2xlXHJcbiAgICAgICAgICAgICAgdXNlcnNUb05vdGlmeS5wdXNoKC4uLmdldCgpLnVzZXJzLmZpbHRlcih1ID0+IHUucm9sZSA9PT0gcm9sZUtleSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGZvciAoY29uc3QgdSBvZiB1c2Vyc1RvTm90aWZ5KSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGdldCgpLmFkZE5vdGlmaWNhdGlvbih7XHJcbiAgICAgICAgICAgICAgbWVzc2FnZV9pZDogbmV3Q29tbWVudC5tZXNzYWdlX2lkLFxyXG4gICAgICAgICAgICAgIHVzZXJfaWQ6IHUuaWQsXHJcbiAgICAgICAgICAgICAgbWVzc2FnZTogYFlvdSB3ZXJlIG1lbnRpb25lZCBpbiBhIGNvbW1lbnRgLFxyXG4gICAgICAgICAgICAgIHJlYWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAobWVudGlvbkVycikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGNyZWF0ZSBtZW50aW9uIG5vdGlmaWNhdGlvbnM6JywgbWVudGlvbkVycilcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5ld0NvbW1lbnRcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBhZGQgY29tbWVudDonLCBlcnJvcilcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9LFxyXG5cclxuICB1cGRhdGVDb21tZW50OiBhc3luYyAoaWQsIGNvbW1lbnREYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBVcGRhdGUgbG9jYWwgc3RhdGVcclxuICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgICBjb21tZW50czogc3RhdGUuY29tbWVudHMubWFwKChjKSA9PiBjLmlkID09PSBpZCA/IHsgLi4uYywgLi4uY29tbWVudERhdGEsIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9IDogYylcclxuICAgICAgfSkpXHJcblxyXG4gICAgICAvLyBUcnkgU3VwYWJhc2VcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgLmZyb20oJ2NvbW1lbnRzJylcclxuICAgICAgICAgIC51cGRhdGUoeyAuLi5jb21tZW50RGF0YSwgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0pXHJcbiAgICAgICAgICAuZXEoJ2lkJywgaWQpXHJcblxyXG4gICAgICAgIGlmIChlcnJvcikgY29uc29sZS53YXJuKCdTdXBhYmFzZSBlcnJvciB1cGRhdGluZyBjb21tZW50OicsIGVycm9yKVxyXG4gICAgICB9IGNhdGNoIChzdXBhYmFzZUVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdTdXBhYmFzZSB1bmF2YWlsYWJsZSB3aGVuIHVwZGF0aW5nIGNvbW1lbnQnLCBzdXBhYmFzZUVycm9yKVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGNvbW1lbnQgbG9jYWxseTonLCBlcnJvcilcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBkZWxldGVDb21tZW50OiBhc3luYyAoaWQpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFJlbW92ZSBmcm9tIGxvY2FsIHN0YXRlXHJcbiAgICAgIHNldCgoc3RhdGUpID0+ICh7IGNvbW1lbnRzOiBzdGF0ZS5jb21tZW50cy5maWx0ZXIoYyA9PiBjLmlkICE9PSBpZCkgfSkpXHJcblxyXG4gICAgICAvLyBUcnkgU3VwYWJhc2VcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgICAgLmZyb20oJ2NvbW1lbnRzJylcclxuICAgICAgICAgIC5kZWxldGUoKVxyXG4gICAgICAgICAgLmVxKCdpZCcsIGlkKVxyXG5cclxuICAgICAgICBpZiAoZXJyb3IpIGNvbnNvbGUud2FybignU3VwYWJhc2UgZXJyb3IgZGVsZXRpbmcgY29tbWVudDonLCBlcnJvcilcclxuICAgICAgfSBjYXRjaCAoc3VwYWJhc2VFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignU3VwYWJhc2UgdW5hdmFpbGFibGUgd2hlbiBkZWxldGluZyBjb21tZW50Jywgc3VwYWJhc2VFcnJvcilcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBjb21tZW50OicsIGVycm9yKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIENvdXJzZSBBY3Rpb25zXHJcbiAgYWRkQ291cnNlOiBhc3luYyAoY291cnNlRGF0YSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ1thZGRDb3Vyc2VdIFN0YXJ0aW5nIHdpdGggZGF0YTonLCBKU09OLnN0cmluZ2lmeShjb3Vyc2VEYXRhLCBudWxsLCAyKSlcclxuICAgICAgXHJcbiAgICAgIC8vIFZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkc1xyXG4gICAgICBpZiAoIWNvdXJzZURhdGEubmFtZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291cnNlIG5hbWUgaXMgcmVxdWlyZWQnKVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghY291cnNlRGF0YS5kZXBhcnRtZW50X2lkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZXBhcnRtZW50IElEIGlzIHJlcXVpcmVkJylcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWNvdXJzZURhdGEuY3JlYXRlZF9ieSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3JlYXRlZCBieSBpcyByZXF1aXJlZCcpXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEdlbmVyYXRlIGEgZGVmYXVsdCBjb2RlIGlmIGVtcHR5IChmcm9tIGNvdXJzZSBuYW1lIGZpcnN0IGxldHRlcnMpXHJcbiAgICAgIGNvbnN0IGNvdXJzZUNvZGUgPSBjb3Vyc2VEYXRhLmNvZGUgJiYgY291cnNlRGF0YS5jb2RlLnRyaW0oKSBcclxuICAgICAgICA/IGNvdXJzZURhdGEuY29kZS50cmltKCkgXHJcbiAgICAgICAgOiBjb3Vyc2VEYXRhLm5hbWUuc3BsaXQoJyAnKS5tYXAodyA9PiB3WzBdKS5qb2luKCcnKS50b1VwcGVyQ2FzZSgpIHx8ICdDT1VSU0UnXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnW2FkZENvdXJzZV0gVmFsaWRhdGlvbiBwYXNzZWQsIGluc2VydGluZyB0byBTdXBhYmFzZS4uLicpXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBkYXRhVG9JbnNlcnQgPSB7XHJcbiAgICAgICAgLi4uY291cnNlRGF0YSxcclxuICAgICAgICBjb2RlOiBjb3Vyc2VDb2RlLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBjb3Vyc2VEYXRhLmRlc2NyaXB0aW9uIHx8IG51bGxcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnY291cnNlcycpXHJcbiAgICAgICAgLmluc2VydChbZGF0YVRvSW5zZXJ0XSlcclxuICAgICAgICAuc2VsZWN0KClcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKCdbYWRkQ291cnNlXSBTdXBhYmFzZSByZXNwb25zZSByZWNlaXZlZCcpXHJcbiAgICAgIGNvbnNvbGUubG9nKCdbYWRkQ291cnNlXSBEYXRhOicsIGRhdGEpXHJcbiAgICAgIGNvbnNvbGUubG9nKCdbYWRkQ291cnNlXSBFcnJvciBwcmVzZW50OicsICEhZXJyb3IpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdbYWRkQ291cnNlXSBTdXBhYmFzZSByZXR1cm5lZCBlcnJvciBvYmplY3QnKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1thZGRDb3Vyc2VdIEVycm9yIGtleXM6JywgT2JqZWN0LmtleXMoZXJyb3IgfHwge30pKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRyeSB0byBleHRyYWN0IGVycm9yIGluZm9ybWF0aW9uXHJcbiAgICAgICAgbGV0IGVycm9yTXNnID0gJ1Vua25vd24gU3VwYWJhc2UgZXJyb3InXHJcbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwpIHtcclxuICAgICAgICAgIGlmICgnbWVzc2FnZScgaW4gZXJyb3IpIGVycm9yTXNnID0gU3RyaW5nKGVycm9yLm1lc3NhZ2UpXHJcbiAgICAgICAgICBpZiAoJ2NvZGUnIGluIGVycm9yKSBjb25zb2xlLmVycm9yKCdbYWRkQ291cnNlXSBFcnJvciBjb2RlOicsIGVycm9yLmNvZGUpXHJcbiAgICAgICAgICBpZiAoJ2RldGFpbHMnIGluIGVycm9yKSBjb25zb2xlLmVycm9yKCdbYWRkQ291cnNlXSBFcnJvciBkZXRhaWxzOicsIGVycm9yLmRldGFpbHMpXHJcbiAgICAgICAgICBpZiAoJ2hpbnQnIGluIGVycm9yKSBjb25zb2xlLmVycm9yKCdbYWRkQ291cnNlXSBFcnJvciBoaW50OicsIGVycm9yLmhpbnQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU3VwYWJhc2UgZXJyb3I6ICR7ZXJyb3JNc2d9YClcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1thZGRDb3Vyc2VdIENvdXJzZSBpbnNlcnRlZCBzdWNjZXNzZnVsbHknKVxyXG4gICAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgICBjb3Vyc2VzOiBbLi4uc3RhdGUuY291cnNlcywgLi4uZGF0YV0sXHJcbiAgICAgICAgfSkpXHJcbiAgICAgICAgcmV0dXJuIGRhdGFbMF0gYXMgQ291cnNlXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUud2FybignW2FkZENvdXJzZV0gTm8gZGF0YSByZXR1cm5lZCBmcm9tIGluc2VydCwgYnV0IG5vIGVycm9yIGVpdGhlcicpXHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdbYWRkQ291cnNlXSBFeGNlcHRpb24gY2F1Z2h0JylcclxuICAgICAgY29uc29sZS5lcnJvcignW2FkZENvdXJzZV0gRXJyb3IgdHlwZTonLCB0eXBlb2YgZXJyb3IpXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1thZGRDb3Vyc2VdIEVycm9yIGNvbnN0cnVjdG9yOicsIGVycm9yPy5jb25zdHJ1Y3Rvcj8ubmFtZSlcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxyXG4gICAgICBjb25zb2xlLmVycm9yKCdbYWRkQ291cnNlXSBFcnJvciBtZXNzYWdlOicsIGVycm9yTWVzc2FnZSlcclxuICAgICAgXHJcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLnN0YWNrKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignW2FkZENvdXJzZV0gU3RhY2sgdHJhY2U6JywgZXJyb3Iuc3RhY2spXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1thZGRDb3Vyc2VdIENvdXJzZURhdGE6JywgSlNPTi5zdHJpbmdpZnkoY291cnNlRGF0YSwgbnVsbCwgMikpXHJcbiAgICAgIFxyXG4gICAgICAvLyBGYWxsYmFjazogYWRkIGNvdXJzZSBvcHRpbWlzdGljYWxseSB0byBsb2NhbCBzdGF0ZVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IG5ld0NvdXJzZTogQ291cnNlID0ge1xyXG4gICAgICAgICAgLi4uY291cnNlRGF0YSxcclxuICAgICAgICAgIGlkOiBNYXRoLm1heCguLi5nZXQoKS5jb3Vyc2VzLm1hcChjID0+IGMuaWQpLCAwKSArIDEsXHJcbiAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbYWRkQ291cnNlXSBBZGRpbmcgY291cnNlIG9wdGltaXN0aWNhbGx5JylcclxuICAgICAgICBzZXQoKHN0YXRlKSA9PiAoeyBjb3Vyc2VzOiBbLi4uc3RhdGUuY291cnNlcywgbmV3Q291cnNlXSB9KSlcclxuICAgICAgICByZXR1cm4gbmV3Q291cnNlXHJcbiAgICAgIH0gY2F0Y2ggKGZhbGxiYWNrRXJyb3IpIHtcclxuICAgICAgICBjb25zdCBmYWxsYmFja01zZyA9IGZhbGxiYWNrRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGZhbGxiYWNrRXJyb3IubWVzc2FnZSA6IFN0cmluZyhmYWxsYmFja0Vycm9yKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1thZGRDb3Vyc2VdIEZhbGxiYWNrIGZhaWxlZDonLCBmYWxsYmFja01zZylcclxuICAgICAgICB0aHJvdyBlcnJvclxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlQ291cnNlOiBhc3luYyAoaWQsIGNvdXJzZURhdGEpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXHJcbiAgICAgICAgLmZyb20oJ2NvdXJzZXMnKVxyXG4gICAgICAgIC51cGRhdGUoeyAuLi5jb3Vyc2VEYXRhLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSlcclxuICAgICAgICAuZXEoJ2lkJywgaWQpXHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcblxyXG4gICAgICBzZXQoKHN0YXRlKSA9PiAoe1xyXG4gICAgICAgIGNvdXJzZXM6IHN0YXRlLmNvdXJzZXMubWFwKChjb3Vyc2UpID0+XHJcbiAgICAgICAgICBjb3Vyc2UuaWQgPT09IGlkXHJcbiAgICAgICAgICAgID8geyAuLi5jb3Vyc2UsIC4uLmNvdXJzZURhdGEsIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9XHJcbiAgICAgICAgICAgIDogY291cnNlXHJcbiAgICAgICAgKSxcclxuICAgICAgfSkpXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBjb3Vyc2U6Jywge1xyXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcclxuICAgICAgICBlcnJvcixcclxuICAgICAgICBjb3Vyc2VJZDogaWQsXHJcbiAgICAgICAgY291cnNlRGF0YSxcclxuICAgICAgfSlcclxuICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgICBjb3Vyc2VzOiBzdGF0ZS5jb3Vyc2VzLm1hcCgoY291cnNlKSA9PlxyXG4gICAgICAgICAgY291cnNlLmlkID09PSBpZFxyXG4gICAgICAgICAgICA/IHsgLi4uY291cnNlLCAuLi5jb3Vyc2VEYXRhLCB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfVxyXG4gICAgICAgICAgICA6IGNvdXJzZVxyXG4gICAgICAgICksXHJcbiAgICAgIH0pKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGRlbGV0ZUNvdXJzZTogYXN5bmMgKGlkKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdjb3Vyc2VzJylcclxuICAgICAgICAuZGVsZXRlKClcclxuICAgICAgICAuZXEoJ2lkJywgaWQpXHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcblxyXG4gICAgICBzZXQoKHN0YXRlKSA9PiAoe1xyXG4gICAgICAgIGNvdXJzZXM6IHN0YXRlLmNvdXJzZXMuZmlsdGVyKChjb3Vyc2UpID0+IGNvdXJzZS5pZCAhPT0gaWQpLFxyXG4gICAgICB9KSlcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGNvdXJzZTonLCB7XHJcbiAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxyXG4gICAgICAgIGVycm9yLFxyXG4gICAgICAgIGNvdXJzZUlkOiBpZCxcclxuICAgICAgfSlcclxuICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgICBjb3Vyc2VzOiBzdGF0ZS5jb3Vyc2VzLmZpbHRlcigoY291cnNlKSA9PiBjb3Vyc2UuaWQgIT09IGlkKSxcclxuICAgICAgfSkpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZmV0Y2hDb3Vyc2VzOiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdjb3Vyc2VzJylcclxuICAgICAgICAuc2VsZWN0KCcqJylcclxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcclxuXHJcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuXHJcbiAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgc2V0KCgpID0+ICh7IGNvdXJzZXM6IGRhdGEgfSkpXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNvdXJzZXM6Jywge1xyXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcclxuICAgICAgICBlcnJvcixcclxuICAgICAgfSlcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBTdWIgQ291cnNlIEFjdGlvbnNcclxuICBhZGRTdWJDb3Vyc2U6IGFzeW5jIChzdWJDb3Vyc2VEYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdzdWJfY291cnNlcycpXHJcbiAgICAgICAgLmluc2VydChbc3ViQ291cnNlRGF0YV0pXHJcbiAgICAgICAgLnNlbGVjdCgpXHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcblxyXG4gICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgICBzdWJDb3Vyc2VzOiBbLi4uc3RhdGUuc3ViQ291cnNlcywgLi4uZGF0YV0sXHJcbiAgICAgICAgfSkpXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBzdWIgY291cnNlOicsIGVycm9yKVxyXG4gICAgICBjb25zdCBuZXdTdWJDb3Vyc2U6IFN1YkNvdXJzZSA9IHtcclxuICAgICAgICAuLi5zdWJDb3Vyc2VEYXRhLFxyXG4gICAgICAgIGlkOiBNYXRoLm1heCguLi5nZXQoKS5zdWJDb3Vyc2VzLm1hcChzYyA9PiBzYy5pZCksIDApICsgMSxcclxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICB9XHJcbiAgICAgIHNldCgoc3RhdGUpID0+ICh7IHN1YkNvdXJzZXM6IFsuLi5zdGF0ZS5zdWJDb3Vyc2VzLCBuZXdTdWJDb3Vyc2VdIH0pKVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZVN1YkNvdXJzZTogYXN5bmMgKGlkLCBzdWJDb3Vyc2VEYXRhKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdzdWJfY291cnNlcycpXHJcbiAgICAgICAgLnVwZGF0ZSh7IC4uLnN1YkNvdXJzZURhdGEsIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KVxyXG4gICAgICAgIC5lcSgnaWQnLCBpZClcclxuXHJcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuXHJcbiAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgc3ViQ291cnNlczogc3RhdGUuc3ViQ291cnNlcy5tYXAoKHN1YkNvdXJzZSkgPT5cclxuICAgICAgICAgIHN1YkNvdXJzZS5pZCA9PT0gaWRcclxuICAgICAgICAgICAgPyB7IC4uLnN1YkNvdXJzZSwgLi4uc3ViQ291cnNlRGF0YSwgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH1cclxuICAgICAgICAgICAgOiBzdWJDb3Vyc2VcclxuICAgICAgICApLFxyXG4gICAgICB9KSlcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHN1YiBjb3Vyc2U6JywgZXJyb3IpXHJcbiAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgc3ViQ291cnNlczogc3RhdGUuc3ViQ291cnNlcy5tYXAoKHN1YkNvdXJzZSkgPT5cclxuICAgICAgICAgIHN1YkNvdXJzZS5pZCA9PT0gaWRcclxuICAgICAgICAgICAgPyB7IC4uLnN1YkNvdXJzZSwgLi4uc3ViQ291cnNlRGF0YSwgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH1cclxuICAgICAgICAgICAgOiBzdWJDb3Vyc2VcclxuICAgICAgICApLFxyXG4gICAgICB9KSlcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBkZWxldGVTdWJDb3Vyc2U6IGFzeW5jIChpZCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgnc3ViX2NvdXJzZXMnKVxyXG4gICAgICAgIC5kZWxldGUoKVxyXG4gICAgICAgIC5lcSgnaWQnLCBpZClcclxuXHJcbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcclxuXHJcbiAgICAgIHNldCgoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgc3ViQ291cnNlczogc3RhdGUuc3ViQ291cnNlcy5maWx0ZXIoKHN1YkNvdXJzZSkgPT4gc3ViQ291cnNlLmlkICE9PSBpZCksXHJcbiAgICAgIH0pKVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgc3ViIGNvdXJzZTonLCBlcnJvcilcclxuICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcclxuICAgICAgICBzdWJDb3Vyc2VzOiBzdGF0ZS5zdWJDb3Vyc2VzLmZpbHRlcigoc3ViQ291cnNlKSA9PiBzdWJDb3Vyc2UuaWQgIT09IGlkKSxcclxuICAgICAgfSkpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZmV0Y2hTdWJDb3Vyc2VzOiBhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAgIC5mcm9tKCdzdWJfY291cnNlcycpXHJcbiAgICAgICAgLnNlbGVjdCgnKicpXHJcbiAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXHJcblxyXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXHJcblxyXG4gICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgIHNldCgoKSA9PiAoeyBzdWJDb3Vyc2VzOiBkYXRhIH0pKVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzdWIgY291cnNlczonLCBlcnJvcilcclxuICAgIH1cclxuICB9LFxyXG59KSlcclxuIl0sIm5hbWVzIjpbImNyZWF0ZSIsInN1cGFiYXNlIiwiZGVtb1VzZXJzIiwiaWQiLCJuYW1lIiwiZW1haWwiLCJwYXNzd29yZCIsInJvbGUiLCJzdGF0dXMiLCJkZXBhcnRtZW50IiwicGhvbmVfbnVtYmVyIiwiZG9iIiwiYWdlIiwiYmxvb2RfZ3JvdXAiLCJjb3Vyc2UiLCJzdWJfY291cnNlIiwicGFyZW50X3Bob25lIiwicmVzcG9uc2libGVfc3RhZmYiLCJkZW1vR3JvdXBzIiwiZGVzY3JpcHRpb24iLCJjcmVhdGVkX2J5IiwibWVtYmVycyIsImNyZWF0ZWRfYXQiLCJEYXRlIiwibm93IiwidG9JU09TdHJpbmciLCJkZW1vRGVwYXJ0bWVudHMiLCJoZWFkX29mX2RlcGFydG1lbnQiLCJ1c2VTdG9yZSIsInNldCIsImdldCIsImN1cnJlbnRVc2VyIiwiaXNBdXRoZW50aWNhdGVkIiwiaXNEYXJrTW9kZSIsInVzZXJzIiwibWVzc2FnZXMiLCJncm91cHMiLCJkZXBhcnRtZW50cyIsImNvdXJzZXMiLCJzdWJDb3Vyc2VzIiwibm90aWZpY2F0aW9ucyIsImNvbW1lbnRzIiwibG9naW4iLCJ1c2VyIiwiZmluZCIsInUiLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJzaW5nbGUiLCJzdGF0ZSIsInN1cGFiYXNlRXJyb3IiLCJjb25zb2xlIiwid2FybiIsIlByb21pc2UiLCJyZXNvbHZlIiwibm9ybWFsaXplZFVzZXIiLCJOdW1iZXIiLCJmdWxsX25hbWUiLCJsb2dvdXQiLCJ0b2dnbGVUaGVtZSIsIm5ld1RoZW1lIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwiYWRkVXNlciIsInVzZXJEYXRhIiwibmV3VXNlciIsIk1hdGgiLCJtYXgiLCJtYXAiLCJ1cGRhdGVkX2F0IiwiaW5zZXJ0IiwibWVzc2FnZSIsImxvZyIsInVwZGF0ZVVzZXIiLCJ1cGRhdGUiLCJkZWxldGVVc2VyIiwiZmlsdGVyIiwiZGVsZXRlIiwiZmV0Y2hVc2VycyIsIm9yZGVyIiwiYXNjZW5kaW5nIiwiYWRkTWVzc2FnZSIsIm1lc3NhZ2VEYXRhIiwic3VwYWJhc2VNZXNzYWdlIiwidGl0bGUiLCJjb250ZW50Iiwic2VuZGVyIiwic2VuZGVyX3JvbGUiLCJyZWNpcGllbnRzIiwiY3VzdG9tX2dyb3VwcyIsInByaW9yaXR5IiwiYXR0YWNobWVudHMiLCJzY2hlZHVsZV90eXBlIiwic2NoZWR1bGVfZGF0ZSIsInNjaGVkdWxlX3RpbWUiLCJ0b3RhbF9yZWNpcGllbnRzIiwicmVhZF9jb3VudCIsInJlYWRfYnkiLCJhY2tub3dsZWRnZWQiLCJhY2tub3dsZWRnZWRfYnkiLCJyZXRyeURhdGEiLCJyZXRyeUVycm9yIiwibmV3TWVzc2FnZSIsIm0iLCJyZWNpcGllbnRVc2VycyIsInRhcmdldEVtYWlscyIsIlNldCIsImFsbEdyb3VwcyIsImZvckVhY2giLCJncm91cElkIiwiZ3JvdXAiLCJnIiwiaGFzIiwiYWRkTm90aWZpY2F0aW9uIiwibWVzc2FnZV9pZCIsInVzZXJfaWQiLCJyZWFkIiwiYWNrbm93bGVkZ2VNZXNzYWdlIiwibWVzc2FnZUlkIiwidXNlcklkIiwiY3VycmVudEFja25vd2xlZGdlZEJ5IiwiaW5jbHVkZXMiLCJuZXdBY2tub3dsZWRnZWRCeSIsIm1zZyIsInVwZGF0ZURhdGEiLCJ1cGRhdGVFcnJvciIsImFja25vd2xlZGdlZEJ5IiwiYWNrRGF0YSIsImFja0luc2VydEVycm9yIiwidXNlcl9uYW1lIiwidXNlcl9lbWFpbCIsInVzZXJfcm9sZSIsImFja25vd2xlZGdlZF9hdCIsImNvZGUiLCJTdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImFja0Vycm9yIiwiZ2V0TWVzc2FnZUFja25vd2xlZGdlbWVudERldGFpbHMiLCJwZW5kaW5nIiwiYWNrbm93bGVkZ2VkVXNlcklkcyIsImFsbFJlY2lwaWVudHMiLCJtYXJrTWVzc2FnZUFzUmVhZCIsImN1cnJlbnRSZWFkQnkiLCJuZXdSZWFkQnkiLCJuZXdSZWFkQ291bnQiLCJmZXRjaE1lc3NhZ2VzIiwic2FmZUNvbHVtbnMiLCJqb2luIiwic2FmZURhdGEiLCJzYWZlRXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJmaXJzdEl0ZW0iLCJyZXRyeUVyciIsImFkZEdyb3VwIiwiZ3JvdXBEYXRhIiwibmV3R3JvdXAiLCJ1cGRhdGVHcm91cCIsImRlbGV0ZUdyb3VwIiwiZmV0Y2hHcm91cHMiLCJhZGREZXBhcnRtZW50IiwiZGVwYXJ0bWVudERhdGEiLCJuZXdEZXBhcnRtZW50IiwiZCIsInVwZGF0ZURlcGFydG1lbnQiLCJvbGREZXBhcnRtZW50Iiwib2xkRGVwdE5hbWUiLCJuZXdEZXB0TmFtZSIsInVzZXJzRXJyb3IiLCJ1cGRhdGVkVXNlcnMiLCJkZWxldGVEZXBhcnRtZW50IiwiZmV0Y2hEZXBhcnRtZW50cyIsIm5vdGlmaWNhdGlvbkRhdGEiLCJleGlzdHNMb2NhbGx5Iiwic29tZSIsIm4iLCJpbmZvIiwiZXhpc3RpbmciLCJzZWxlY3RFcnJvciIsImxpbWl0IiwiZXJyIiwibmV3Tm90aWZpY2F0aW9uIiwibWFya05vdGlmaWNhdGlvbkFzUmVhZCIsIm5vdGlmIiwibWFya05vdGlmaWNhdGlvbnNBc1JlYWRGb3JNZXNzYWdlIiwiZ2V0VW5yZWFkTm90aWZpY2F0aW9ucyIsImZldGNoQ29tbWVudHMiLCJhZGRDb21tZW50IiwiY29tbWVudERhdGEiLCJzYXZlZENvbW1lbnQiLCJuZXdDb21tZW50IiwiYyIsIm5vdGlmeUVyciIsIm1lbnRpb25zIiwibWF0Y2giLCJyb2xlcyIsInJlcGxhY2UiLCJ1c2Vyc1RvTm90aWZ5Iiwicm9sZUtleSIsInB1c2giLCJtZW50aW9uRXJyIiwidXBkYXRlQ29tbWVudCIsImRlbGV0ZUNvbW1lbnQiLCJhZGRDb3Vyc2UiLCJjb3Vyc2VEYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsIkVycm9yIiwiZGVwYXJ0bWVudF9pZCIsImNvdXJzZUNvZGUiLCJ0cmltIiwic3BsaXQiLCJ3IiwidG9VcHBlckNhc2UiLCJkYXRhVG9JbnNlcnQiLCJPYmplY3QiLCJrZXlzIiwiZXJyb3JNc2ciLCJkZXRhaWxzIiwiaGludCIsImVycm9yTWVzc2FnZSIsInN0YWNrIiwibmV3Q291cnNlIiwiZmFsbGJhY2tFcnJvciIsImZhbGxiYWNrTXNnIiwidXBkYXRlQ291cnNlIiwiY291cnNlSWQiLCJkZWxldGVDb3Vyc2UiLCJmZXRjaENvdXJzZXMiLCJhZGRTdWJDb3Vyc2UiLCJzdWJDb3Vyc2VEYXRhIiwibmV3U3ViQ291cnNlIiwic2MiLCJ1cGRhdGVTdWJDb3Vyc2UiLCJzdWJDb3Vyc2UiLCJkZWxldGVTdWJDb3Vyc2UiLCJmZXRjaFN1YkNvdXJzZXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/store.ts\n"));

/***/ })

});